<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Projects - Aamir Irfan Portfolio</title>
  <!-- Prism.js CSS for syntax highlighting -->
  <link href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism-tomorrow.css" rel="stylesheet" />
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      background-color: #0d0d0d;
      color: white;
      text-align: justify;
    }
    header {
      background-color: #1a1a1a;
      padding: 2rem;
      text-align: center;
      border-bottom: 2px solid red;
    }
    header h1 {
      margin: 0;
      font-size: 2.5rem;
    }
    nav a {
      color: red;
      margin: 0 1rem;
      text-decoration: none;
    }
    nav a:hover {
      text-decoration: underline;
    }
    .container {
      padding: 2rem;
      max-width: 1000px;
      margin: auto;
    }
    .nav-bar {
      display: flex;
      gap: 1rem;
      background: #1a1a1a;
      padding: 0.5rem;
      margin-bottom: 1rem;
      overflow-x: auto;
    }
    .nav-bar button {
      background: none;
      color: red;
      border: 1px solid red;
      padding: 0.5rem 1rem;
      cursor: pointer;
      white-space: nowrap;
    }
    .nav-bar button.active {
      background: red;
      color: white;
    }
    .project-detail {
      background-color: #1a1a1a;
      padding: 1.5rem;
      border-left: 4px solid red;
    }
    /* --- Gallery layout --- */
    .project-media {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); /* repeat(2, 1fr);exactly 2 columns *//*repeat(auto-fit, minmax(300px, 1fr));*/
      gap: 1rem;
      margin-top: 1rem;
    }
    .project-media img,
    .project-media video,
    .project-media iframe {
      width: 100%;
      border: 2px solid red;
      border-radius: 6px;
    }
    .download {
      display: inline-block;
      margin: 0.5rem 0.5rem 0 0;
      padding: 0.5rem 1rem;
      background: red;
      color: white;
      text-decoration: none;
      border-radius: 3px;
    }
    .links {
      margin-top: 1rem;
    }
    .links a {
      display: inline-block;
      margin-right: 1rem;
      color: red;
      text-decoration: none;
      border: 1px solid red;
      padding: 0.3rem 0.6rem;
      border-radius: 3px;
      transition: background-color 0.3s;
    }
    .links a:hover {
      background-color: red;
      color: white;
    }
    pre[class*="language-"] {
      margin-top: 1rem;
      border-radius: 4px;
      font-size: 0.9rem;
    }

    .responsive-video {
      position: relative;
      width: 100%;
      padding-top: 56.25%; /* 16:9 aspect ratio (9/16 = 0.5625) */
    }

    .responsive-video iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border: 2px solid red;
      border-radius: 6px;
    }

  </style>
</head>
<body>

<header>
  <h1>Hey, I am Aamir Irfan ðŸ‘‹</h1><br>
  <nav>
    <a href="index.html">Home</a>
    <a href="projects.html" style="text-decoration: underline;">Projects (Explorative View)</a>
    <a href="index.html#contact">Contact</a>
    <a href="index.html#resume">Resume</a>
  </nav>
</header>

<div class="container">
  <div class="nav-bar" id="category-nav"></div>
  <div class="nav-bar" id="project-nav"></div>

  <div class="project-detail" id="project-detail">
    <h2>Select a project</h2>
    <p>Click on a project above to see details here.</p>
  </div>
</div>

<!-- Prism.js -->
<script src="https://cdn.jsdelivr.net/npm/prismjs/prism.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-javascript.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-python.min.js"></script>

<script>
  const projectsData = {
    "Full-Stack": [
      {
        id: "Inventory_Management_Application",
        name: "Inventory Management Application",
        summary: [
          "<u><b>Building Process</b></u>",
          "The building process of the full-stack web app was done by first installing all the software and dependencies required to build the project. The best way to achieve this will be to follow the documentation of the project on my GitHub repository <a href=https://github.com/Aamir-Ir/Inventory-Management-Application/blob/main/README.md>(READ.ME)</a>.",
          "The <u><b>database</b></u> was designed for a company to host on the clientâ€™s local server which required data to be backed up everyday. This allows for the system to save their database on a daily basis, how I achieved this was by using <b>SQL Server Express</b> to create an instance which could be saved. I could connect to that instance with <b>Microsoft SQL Server Management Studio (SSMS)</b>. I also connected to this database instance with VS Code by using an API along with a library named <b>pyodbc</b> which allows applications to access data for database management systems.",
          "The <u><b>backend</b></u> was built with <b>Python</b> with a <b>Flask</b> micro-webservice for handling all logic, database management, and server side operations.",
          "The <u><b>frontend</b></u> was built with <b>HTML</b>, <b>CSS</b>, and <b>JavaScript</b> for UI/UX.",
          "The <u><b>Security</b></u> in this project was very important as inventory tracking had to be accurate and not be tampered with as this would cause delays. How I did this was by making sure that the administrator would create an account for every user and the passwords were creating with a hashing algorithm so it would be impossible to decode the password to access the site. Next there were 3 privileges on the server (Admin, Manager, & employee) the manager and employee had enough access to the tables so that they would not damage the data set as they could only alter fields in tables or at most a column each change was tracked so we would know who did what. The backend could not be used to add or delete tables all of that was done through SSMS which is where major changes were made. Finally if something did go wrong we could revert to a previous save or the administrator could try to fix it.",
          "<u><b>Project Impact</b></u>",
          "This project was created for a company named Reena Enterprises Limited (Total Health Centre), this project is used to store all the inventory information inside of Total Health Centre this allows them to create orders and keep track of inventory virtually. <b>This eliminated 2 hours of counting time</b> for the inventory daily also it streamlined workflows as tickets could be made faster with accuracy allowing for products to be made faster as the team always knew they had raw materials in stock. The system also reduced errors in inventory tracking and overall boosted the performance of the team and led to more sales.",
          "<u><b>Key Skills:</b></u> Python | JavaScript | HTML | CSS | Flask | SQL | Visual Studio Code | Microsoft SQL Server Managment Studio | SQL Server Express | Git | API | Developing Secure Code."
        ],
        images: [],
        videos: ["https://drive.google.com/file/d/1JFzMwJuoGDxpm8znIGZQ-JlgwjU3Fz4d/preview"],
        downloads: [],
        links: [
          { label: "GitHub Repository", url: "https://github.com/Aamir-Ir/Inventory-Management-Application" }
        ],
        code: null
      },
      {
        id: "User_Management_Application",
        name: "User Management Application",
        summary: [
          "<u><b>Building Process</b></u>",
          "The building process of the full-stack web app was done by first installing all the software and dependencies required to build the project. The best way to achieve this will be to follow the documentation of the project on my GitHub repository <a href=https://github.com/Aamir-Ir/Inventory-Management-Application/blob/main/README.md>(READ.ME)</a>.",
          "The <u><b>database</b></u> was designed for a company to host on the clientâ€™s local server which required data to be backed up everyday. This allows for the system to save their database on a daily basis, how I achieved this was by using <b>SQL Server Express</b> to create an instance which could be saved. I could connect to that instance with <b>Microsoft SQL Server Management Studio (SSMS)</b>. I also connected to this database instance with VS Code by using an API along with a library named <b>pyodbc</b> which allows applications to access data for database management systems.",
          "The <u><b>backend</b></u> was built with Python with a Flask micro-webservice for handling all logic, database management, and server side operations.",
          "The <u><b>frontend</b></u> was built with <b>HTML</b>, <b>CSS</b>, and <b>JavaScript</b> for UI/UX.",
          "The <u><b>Security</b></u> in this project was very important as this held all the information on employees and their company devices. How I did this was by making sure that the administrator would create an account for every new user and the passwords were creating with a hashing algorithm so it would be impossible to decode the password to access the site. All changes was tracked so we would know who did what. The backend could not be used to add or delete tables all of that was done through SSMS which is where major changes were made. Finally if something did go wrong we could revert to a previous save or the administrator could try to fix it.",
          "<u><b>Project Impact</b></u>",
          "This project was created for the IT team that works at Reena Enterprises Limited (Total Health Centre), this project is used to store all the devices and systems under the company network along with all the software the devices use. It is mainly used to track over 75 employees by tracking what software are required for their tasks, and helping track the companies resources.",
          "<u><b>Key Skills:</b></u> Python | JavaScript | HTML | CSS | Flask | SQL | Visual Studio Code | Microsoft SQL Server Managment Studio | SQL Server Express | Git | API | Developing Secure Code."
        ],
        images: ["assets/User_Man_Login.png", "assets/User_Man_Hope_Page.png", "assets/User_Man_Add_System.png", "assets/User_Man_Change_Pass.png", "assets/User_Man_Manage_System_Access.png", "assets/User_Man_Remove_System_Access.png"],
        videos: [],
        downloads: [],
        links: [
          { label: "GitHub Repository", url: "https://github.com/Aamir-Ir/User_Management_Application" }
        ],
        code: null
      },
      {
        id: "Molecule_Viz_App",
        name: "Molecule Visualization Application",
        summary: [
          "<u><b>Building Process</b></u>",
          "Utilized <b>C</b> and <b>Python</b> to develop a backend program that parsed chemical compounds from molecular data and stored the information in a SQL database using the SQLite library, resulting in a streamlined process of creating molecules based on SDF files and establishing structural connections within the database.",
          "The <u><b>database</b></u> was created using <b>SQLite3</b> library in Python.",
          "The <u><b>backend</b></u> was built with <b>Python</b> & <b>C</b> for handling all logic, database management, and server side operations.",
          "The <u><b>frontend</b></u> was built with <b>HTML</b>, <b>CSS</b>, and <b>JavaScript</b> for UI/UX.",
          "The <u><b>Security</b></u> of the design ensures that there is limited possiblity for a malicious hacker to perform SQL and HTML injections.",
          "<u><b>Project Impact</b></u>",
          "This project was created to execute a comprehensive <b>Waterfall Software Development Life Cycle</b> by meticulously understanding the system requirements, designing the architecture, coding functionalities, integrating components, and thoroughly testing the system to ensure it met all specifications.",
          "<u><b>Key Skills:</b></u> C | Python | JavaScript | HTML | CSS | SQLite | Visual Studio Code | Git."
        ],
        images: ["assets/mol_1.png", "assets/mol_3.png", "assets/mol_2.png", "assets/mol_4.png", "assets/mol_5.png", "assets/mol_6.png"],
        videos: [],
        downloads: [],
        links: [
          { label: "GitHub Repository", url: "https://github.com/Aamir-Ir/Molecule-Visualization-Application" }
        ],
        code: null
      },
      {
        id: "Portfolio_App",
        name: "Personal Portfolio Website",
        summary: [
          "<u><b>Building Process</b></u>",
          "The building process of the full-stack web app was done mainly by writing front-end code and placing all assets and downloadable material in correct folders in the GitHub Repository. Visual Studio Code editor was used and Git was used for version control.",
          "The <u><b>database</b></u> is the GitHub Respository as it holds all the information required mainly pictures and forms.",
          "The <u><b>backend</b></u> is handled by GitHub.",
          "The <u><b>frontend</b></u> was built with HTML, CSS, and JavaScript for UI/UX.",
          "<u><b>Project Impact</b></u>",
          "This project will showcase all my projects and detail them. The viewer should understand each projects building process, community impact, and key skills.",
          "<u><b>Key Skills:</b></u> JavaScript | HTML | CSS | Visual Studio Code | Git."
        ],
        images: [],
        videos: [],
        downloads: [],
        links: [
          { label: "GitHub Repository", url: "https://github.com/Aamir-Ir/Aamir-Ir.github.io" }
        ],
        code: null
      }
    ],
    "Embedded": [
      {
        id: "RISC_V",
        name: "RISC-V Interpreter",
        summary: [
          "<u><b>Building Process</b></u>",
          "This project implements a custom RISC-V 32-bit instruction set simulator in Python. The interpreter models 32 registers, a program counter (PC), simulated memory, and instruction execution logic. Labels and control flow features such as branching and jumping are also supported. The program was coded in Python using Visual Studio Code, the code as test cases that will be read from text files containing RISC-V code. See GitHub for all files <a href=https://github.com/Aamir-Ir/RISC-V_Interpreter>(GIT REPO)</a>.",
          "The build process involved designing the interpreter structure, mapping each instruction to its corresponding method, handling labels during parsing, and simulating memory operations. Extensive debugging was carried out with test assembly programs to validate correctness against expected RISC-V behavior.",
          "<u><b>Project Impact</b></u>",
          "The project has educational impact as it demonstrates how computer architecture concepts such as registers, memory, load/store operations, branching, and cycle counting are implemented at a fundamental level. It can serve as a teaching tool for those learning RISC-V or computer organization.",
          "<u><b>Key Skills:</b></u> Python | Simulation & Emulation of Instruction Sets | Debugging Parsers | Software Architecture for Interpreters | Understanding of RISC-V ISA | Low-Level System Design | Visual Studio Code | Git."
        ],
        images: [],
        videos: [],
        downloads: ["downloads/riscv-interpreter.zip"],
        links: [{ label: "GitHub Repository", url: "https://github.com/Aamir-Ir/RISC-V_Interpreter"}],
        code: `# README: Look for README (cntrl + F) to find execution instructions. 

class RISC_V_Interpreter:

    ''''
        Intial Constructor Method Used to define the basic instances of the object. 

        ->  RISC_V_Interpreter
            
            1) RISC-V 32 Bit ISA with 32 Registers.
            2) Memory Simulation to showcase how the load/store instructions are handled.
            3) PC used to keep track of the sequential flow of the program along with help with Jump type instructions.
            4) Instruction count used to count the number of instructions. (Since it is a Single Cycle Processor the Cycle Count = Instructions Count and CPI = 1 = IPC).
            5) Recently Added: Labels are stored if a program contains labels in the input. Used mainly for jump instruction programs. 
    '''

    def __init__(self):
        self.registers = {i: 0 for i in range(32)}      # Each Register Declared and Initialized to 0. (All 32 of them).
        self.memory = {}                                # Simulated memory by the end will showcase what was stored in memory by sw instructions and if something is not there it will be removed by lw. This is what happens in RIPES I will mention this int he report.
        self.pc = 0                                     # Program Counter
        self.instrCount = 0                             # Instruction Counter.
        self.labels = {}                                # File Parsing will set this variable.
        
        # All possible instructions that can be dealt with by the RISC_V_Interpreter are stored in a dictionary format with appropriate instance calls to invoke them when parsing.

        self.instructions = {
            "ADD": self.ADD,                            # Addition Instruction.
            "SUB": self.SUB,                            # Subtraction Instruction.
            "LI": self.LI,                              # Load Immediate Instruction.
            "LW": self.LW,                              # Load Word Instruction.
            "SW": self.SW,                              # Store Word Instruction.
            "BEQ": self.BEQ,                            # Branch If Equal Instruction.
            "JAL": self.JAL,                            # Jump And Link Register Instruction.
            "J": self.J                                 # Jump Instruction to a specfic label.
        }

    # Addition Method. RD = R1 + R2.

    def ADD(self, RD, R1, R2):
        self.registers[RD] = self.registers[R1] + self.registers[R2]
    
    # Subtraction Method. RD = R1 - R2.

    def SUB(self, RD, R1, R2):
        self.registers[RD] = self.registers[R1] - self.registers[R2]
    
    # Load Immediate Method. RD = IMM.

    def LI(self, RD, IMM):
        self.registers[RD] = IMM

    # Load Word Method. RD = Base Register (Rbase) + OFFSET.

    def LW(self, RD, Rbase, OFFSET):
        address = self.registers[Rbase] + OFFSET
        self.registers[RD] = self.memory.get(address, 0)
    
    # Store Word Method. In Memory at Base Register (Rbase) + OFFSET store R1.

    def SW(self, R1, Rbase, OFFSET):
        address = self.registers[Rbase] + OFFSET
        self.memory[address] = self.registers[R1]

    # Branch If Equal. IF R1 = R2 Branch.
    
    def BEQ(self, R1, R2, OFFSET):
        if self.registers[R1] == self.registers[R2]:
            print("BEQ condition met (would branch to PC +", OFFSET, ") but executing sequentially.")
            # For this simulation we do not change self.pc.
    
    # Jump And Link Register.

    def JAL(self, *args):

        # Modified to accept either one operand (label only) or two operands (RD and OFFSET)
        
        # Case 1: If a label is given.

        if len(args) == 1:
            OFFSET = args[0]
            RD = 1  # Default link register (RA) if not specified.

        # Case 2: If Two operands are given RD and OFFSET.

        elif len(args) == 2:
            RD, OFFSET = args
        
        # Case 3: Something went wrong in the file input the form must be wrong.

        else:
            raise ValueError("Invalid number of operands for JAL")
        
        # Store return address

        self.registers[RD] = self.pc + 1
        
        # Jump by OFFSET.

        self.pc += OFFSET  
    
    # Jump Instruction.

    def J(self, OFFSET):

        # Case 1: Reset

        if OFFSET == 0:
            
            # Stop the execution by forcing PC to be beyond the program length. I believe this will always work especially since j is at the end of a function.

            self.pc = 10**9

        # Case 2: Continue.

        else:

            # Adjust PC (subtract 1 because execute_program will add 1).

            self.pc += OFFSET - 1

    # Execute the Program Method used to run the RISC_V_Interpreter.

    def execute_program(self, program_code):

        # While the Program Counter has instructions to run keep reading. 

        while self.pc < len(program_code):
            self.instrCount += 1                                                # Reads a line + 1 to the Instruction Count.
            instruction = program_code[self.pc].split()                         # Split the instruction and place into the program code list, while holding the current instruction.
            opcode = instruction[0].upper()                                     # Convert opcode to uppercase for robustness.
            
            # Process operands: try converting to integers; if it fails it then becomes a label as it is not compatible with an integer type.
            
            operands = []

            # Read the instruction.

            for token in instruction[1:]:
            
                # Base Case: We have registers in the instrucitons. 

                try:
                    operand = int(token)

                # Label Case: We have a label as no integers were detected.

                except ValueError:

                    # The OPCODES preceding a label.

                    if opcode in ["BEQ", "JAL", "J"]:
                        operand = self.labels[token] - self.pc

                    # Only OPCODES labels.

                    else:
                        operand = self.labels[token]

                operands.append(operand)
            
            if opcode in self.instructions:
                self.instructions[opcode](*operands)
            
            # Always move to next instruction for sequential execution

            self.pc += 1 

        # Dump final register values that are 0 to make it easy to read.

        print("\nFinal Register State (Only Included Non-Zero Registers):")
        
        for reg, value in self.registers.items():
            if value != 0:
                print(f"R{reg}: {value}")

        # Printing out the state of the memory.

        print("\nMemory State:")
        print(self.memory)

        # Printing out the Execution Metrics.
        #  
        print("\nExecution Metrics:")
        print(f"- Total Instructions Executed: {self.instrCount}")
        print(f"- Total Cycles Used: {self.instrCount}")
        print("- CPI = IPC = 1 (Single Cycle Processor).\n")

# Load Program from the file input. On command terminal type: "filename.txt" (Do not forget the .txt extention)

filename = input("Enter the filename: ")

program_code = []       # Used to store each instruction.
labels = {}             # Used to store labels and mapping them to specific instructions.
current_index = 0

# Expected flow of program.

try:
    
    # Read filename.

    with open(filename, "r") as file:
        textfile_lines = file.readlines()
        
        # Ignore the first line (variable assignment) if needed.
    
        for line in textfile_lines[1:]:
            line = line.strip().strip('",')             #  Remove quotes in the instructions.
            if not line or line == "]":                 #  Remove Brackets in the instructions.
                continue

            line = line.replace(",", "")                # Remove commas from the line.
            
            # If the line is a label (ends with ':'), record its position.

            if line.endswith(":"):
                label_name = line[:-1]
                labels[label_name] = current_index
            else:
                program_code.append(line)
                current_index += 1

    # Print out the summary of what was parsed from the file.
    print("\nSummary of Parsed File (Including Instructions + Labels):")
    print("Parsed Program List:", program_code)
    print("Labels:", labels)

# Errors that are not part of the expected flow of the program.

except FileNotFoundError:
    print(f"Error: The file '{filename}' was not found.")
    exit()
except Exception as e:
    print(f"An error occurred: {e}")
    exit()

# Main of the program think of this as the starting point from the POV of the compiler and run the program.

class_interpreter = RISC_V_Interpreter()              # Declare and intialize the RISC_V_Interpreter.
class_interpreter.labels = labels                     # Send the labels to the interpreter after reading the file.
class_interpreter.execute_program(program_code)       # Actually Execute the code noe.

# README: You have to input a text file with its name: "filename.txt" to run the program. I tested the testcases given on courselink with this method. `
      },
      {
        id: "Full_CPU",
        name: "Full CPU Final",
        summary: [
          "Temperature and humidity sensor with cloud upload.",
          "The device logs data locally and pushes to the cloud periodically."
        ],
        images: ["assets/iot-sensor.jpg"],
        videos: [],
        downloads: ["assets/iot-sensor-firmware.zip", "assets/schematics.pdf"],
        links: [],
        code: ``
      },
      {
        id: "Full_CPU_1",
        name: "CPU RTL Design (Pt 1): Full Datapath Design",
        summary: [
          "Temperature and humidity sensor with cloud upload.",
          "The device logs data locally and pushes to the cloud periodically."
        ],
        images: ["assets/CO_L3_1.png"],
        videos: [],
        downloads: ["downloads/CO_L3.zip"],
        links: [{ label: "GitHub Repository", url: "https://github.com/Aamir-Ir/VHDL_Achievements/tree/main/VHDL%20-%20Advanced/CPU%20Design%201"}],
        code: `-- VHDL SOURCE CODE FILE FOR TOP MODULE (CO_L3):
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;


entity CPU_3380 is
	port(
		clk	: in std_logic;
		clear : in std_logic;
		mem_dump : in std_logic := '0';
		instruction : in std_logic_vector(15 downto 0)
 	);
end CPU_3380;

architecture Behavioral of CPU_3380 is
	COMPONENT ALU_16Bit
		port(
			A			:	in		std_logic_vector(15 downto 0);
			B			:	in		std_logic_vector(15 downto 0);
			S			:	in		std_logic_vector(1 downto 0);
			Sout		:	out 	std_logic_vector(15 downto 0);
			Cout		:	out	std_logic
		);
	END COMPONENT;

	COMPONENT Registers
		port(
			clk			:	in	 std_logic;
			clear			:	in  std_logic;

			a_addr		:	in	 std_logic_vector( 3 downto 0);
			a_data		:	in	 std_logic_vector(15 downto 0);
			load			:	in	 std_logic;

			b_addr		:	in	 std_logic_vector( 3 downto 0);
			c_addr		:	in	 std_logic_vector( 3 downto 0);

			b_data		:	out std_logic_vector(15 downto 0);
			c_data		:	out std_logic_vector(15 downto 0)
		);
	END COMPONENT;

  -- TODO 1: Implement the control component
Component Control
	port(
		op			:	in	std_logic_vector( 3 downto 0);
		alu_op		:	out	std_logic_vector( 1 downto 0);
		alu_src		:	out	std_logic;
		reg_dest	:	out	std_logic;
		reg_load	:	out	std_logic;
		reg_src		:	out	std_logic_vector(1 downto 0);
		mem_read	:	out	std_logic;
		mem_write	:	out	std_logic
		);
		end component;
  -- TODO 2: Implement the signextend component
component Signextend
	port(
		immIn		:	in	std_logic_vector( 3 downto 0);
		immOut		:	out	std_logic_vector(15 downto 0)
		);
		end component;

	component mux3_1
   generic (WIDTH : positive:=16);
	port(
		Input1		:	in		std_logic_vector(WIDTH-1 	downto 0);
		Input2		:	in		std_logic_vector(WIDTH-1 	downto 0);
		Input3		:	in		std_logic_vector(WIDTH-1 	downto 0);
		S				:	in		std_logic_vector(1 			downto 0);
		Sout			:	out	std_logic_vector(WIDTH-1 	downto 0));
	end component;

	component mux2_1
   generic (WIDTH : positive:=16);
	port(
		Input1		:	in		std_logic_vector(WIDTH-1 	downto 0);
		Input2		:	in		std_logic_vector(WIDTH-1 	downto 0);
		S				:	in		std_logic;
		Sout			:	out	std_logic_vector(WIDTH-1 	downto 0));
	end component;

	-- Signals
	signal  op						:	std_logic_vector( 3 downto 0)	;
	signal	rd						:	std_logic_vector( 3 downto 0)	;
	signal	rs						:	std_logic_vector( 3 downto 0)	;
	signal	rt						:	std_logic_vector( 3 downto 0)	;

	signal	alu_result			:	std_logic_vector(15 downto 0)	;
	signal	cout					:	std_logic							;
	signal	alu_src_mux_out	:	std_logic_vector(15 downto 0)	;
	signal 	sign_ex_out			:	std_logic_vector(15 downto 0)	;
	signal	rs_data				:	std_logic_vector(15 downto 0)	;
	signal	rt_data				:	std_logic_vector(15 downto 0)	;
	signal	reg_dest_mux_out	:	std_logic_vector( 3 downto 0)	;
	signal	reg_src_mux_out	:	std_logic_vector(15 downto 0)	;

	signal	ctrl_alu_src		:	std_logic							;
	signal	ctrl_alu_op			:	std_logic_vector( 1 downto 0)	;
	signal	ctrl_reg_dest		:	std_logic							;
	signal	ctrl_reg_src		:	std_logic_vector( 1 downto 0)	;
	signal	ctrl_reg_load		:	std_logic							;
	signal	ctrl_mem_read		:	std_logic							;
	signal	ctrl_mem_write		:	std_logic							;

begin
	--------------------------------------------------------------------------
	-- Instruction Fetch
	--------------------------------------------------------------------------
	op		<=	instruction(15 downto 12);
	rd		<= instruction(11 downto  8);
	rs		<= instruction(7  downto  4);
	rt		<= instruction(3  downto  0);
	--------------------------------------------------------------------------
	-- Instruction Decode
	--------------------------------------------------------------------------
	-- TODO 3: Implement the complete port map for the control
    ControlUnit: Control port map(
    op,ctrl_alu_op,ctrl_alu_src,ctrl_reg_dest,ctrl_reg_load,
    ctrl_reg_src, ctrl_mem_read, ctrl_mem_write
    );
	-- TODO 4: Finish the port map for the register file
	CPU_Registers_0:		Registers port map(
		clk			=>		clk,
		clear			=>		clear,
		a_addr		=>		rd,
		a_data		=>		alu_result,
		load			=>		ctrl_reg_load,
		b_addr		=>		rs,
		c_addr		=>		reg_dest_mux_out,
		b_data		=>		rs_data,
		c_data		=>		rt_data
	);

-- TODO 5: Implement the complete port map for the signextend
SignExt: Signextend port map(
rt, sign_ex_out
);

CPU_reg_dest_mux:		mux2_1 generic map(4) port map(
	Input1		=>		rt,
	Input2		=>		rd,
	S				=>		ctrl_reg_dest,
	Sout			=>		reg_dest_mux_out
);

	--------------------------------------------------------------------------
	-- Execute
	--------------------------------------------------------------------------
	CPU_alu_src_mux:		mux2_1 generic map(16) port map(
		Input1		=>		rt_data,
		Input2		=>		sign_ex_out,
		S				=>		ctrl_alu_src,
		Sout			=>		alu_src_mux_out
	);

	CPU_ALU_0:				ALU_16Bit port map(
		A				=>		rs_data,
		B				=>		alu_src_mux_out,
		S				=>		ctrl_alu_op,
		Sout			=>		alu_result,
		Cout			=>		cout
	);

	--------------------------------------------------------------------------
	-- Memory
	--------------------------------------------------------------------------
	-- Not in this lab

	--------------------------------------------------------------------------
	-- Write Back
	--------------------------------------------------------------------------
	-- Not in this lab

end Behavioral;


----------------------------------------------------------------------------------
-- VHDL CODE FOR ALU_16Bit:
----------------------------------------------------------------------------------

Library ieee;
Use ieee.std_logic_1164.all;
Use ieee.std_logic_unsigned.all;

Entity ALU_16Bit is
port(	
		A		:	in		std_logic_vector(15 downto 0);
		B		:	in		std_logic_vector(15 downto 0);
		S		:	in		std_logic_vector(1 downto 0);
		Sout	:	out 	std_logic_vector(15 downto 0);
		Cout	:	out	std_logic
);
End;

Architecture behavior of ALU_16Bit is
	COMPONENT ALU
	port(	
		A		:	in		std_logic;
		B		:	in		std_logic;
		Cin	:	in		std_logic;
		S		:	in		std_logic_vector(1 downto 0);
		Sout	:	out 	std_logic;
		Cout	:	out	std_logic
	);
	END COMPONENT;

	signal Carry		:	std_logic_vector(14 downto 0);

Begin
	alu00	:	ALU	port map(A(0),		B(0),		S(0),			S,	Sout(0),		Carry(0));
	alu01	:	ALU	port map(A(1),		B(1),		Carry(0),	S,	Sout(1),		Carry(1));
	alu02	:	ALU	port map(A(2),		B(2),		Carry(1),	S,	Sout(2),		Carry(2));
	alu03	:	ALU	port map(A(3),		B(3),		Carry(2),	S,	Sout(3),		Carry(3));
	
	alu04	:	ALU	port map(A(4),		B(4),		Carry(3),	S,	Sout(4),		Carry(4));
	alu05	:	ALU	port map(A(5),		B(5),		Carry(4),	S,	Sout(5),		Carry(5));
	alu06	:	ALU	port map(A(6),		B(6),		Carry(5),	S,	Sout(6),		Carry(6));
	alu07	:	ALU	port map(A(7),		B(7),		Carry(6),	S,	Sout(7),		Carry(7));

	alu08	:	ALU	port map(A(8),		B(8),		Carry(7),	S,	Sout(8),		Carry(8));
	alu09	:	ALU	port map(A(9),		B(9),		Carry(8),	S,	Sout(9),		Carry(9));
	alu10	:	ALU	port map(A(10),	B(10),	Carry(9),	S,	Sout(10),	Carry(10));
	alu11	:	ALU	port map(A(11),	B(11),	Carry(10),	S,	Sout(11),	Carry(11));

	alu12	:	ALU	port map(A(12),	B(12),	Carry(11),	S,	Sout(12),	Carry(12));
	alu13	:	ALU	port map(A(13),	B(13),	Carry(12),	S,	Sout(13),	Carry(13));
	alu14	:	ALU	port map(A(14),	B(14),	Carry(13),	S,	Sout(14),	Carry(14));
	alu15	:	ALU	port map(A(15),	B(15),	Carry(14),	S,	Sout(15),	Cout);
End;

----------------------------------------------------------------------------------
-- VHDL CODE FOR ALU:
----------------------------------------------------------------------------------

Library ieee;
Use ieee.std_logic_1164.all;
Use ieee.std_logic_unsigned.all;

Entity ALU is
port(	
		A	:	in	std_logic;
		B	:	in	std_logic;
		Cin	:	in	std_logic;
		S	:	in	std_logic_vector(1 downto 0);
		Sout:	out std_logic;
		Cout:	out	std_logic
);
End;

Architecture behavior of ALU is
    COMPONENT full_adder
	port(	
		A	:	in	std_logic;
		B	:	in	std_logic;
		Cin	:	in	std_logic;
		Sout	:	out std_logic;
		Cout:	out	std_logic
		);
    END COMPONENT;
	
	component MUX31
	port(	
		Input1		:	in	std_logic;
		Input2		:	in	std_logic;
		Input3		:	in	std_logic;
		S			:	in	std_logic_vector(1 downto 0);
		Sout		:	out	std_logic
		);
	end component;
	
	component and_gate
	port(	
		In1		:	in	std_logic;
		In2		:	in	std_logic;
		Sout	:	out	std_logic
		);
	end component;	
	
	component or_gate
	port(	
		In1		:	in	std_logic;
		In2		:	in	std_logic;
		Sout	:	out	std_logic
		);
	end component;
	
--Signals Defination
	signal Sout_full_adder	:	std_logic;
	signal Sout_or_gate		:	std_logic;
	signal Sout_and_gate		:	std_logic;
	signal NB					:	std_logic;
Begin

	NB <= B xor S(0);
	
	C1:full_adder	port map(
		A		=>	A,
		B		=>	NB,
		Cin	=>	Cin,
		Sout	=>	Sout_full_adder,
		Cout	=>	Cout
	);

	C2:and_gate	port map(
		In1	=>	A,
		In2	=> B,
		Sout	=> Sout_and_gate
	);
	
	C3:or_gate		port map(
		In1	=>	A,
		In2	=>	B,
		Sout	=>	Sout_or_gate
	);
	
	C4:MUX31		port map(
		Input1	=>	Sout_full_adder,
		Input2	=>	Sout_and_gate,
		Input3	=>	Sout_or_gate,
		S			=>	S,
		Sout		=>	Sout
	);
	
End;

----------------------------------------------------------------------------------
-- VHDL CODE FOR full_adder:
----------------------------------------------------------------------------------

Library ieee;
Use ieee.std_logic_1164.all;
Use ieee.std_logic_unsigned.all;

Entity full_adder is
port(	
		A	:	in	std_logic;
		B	:	in	std_logic;
		Cin	:	in	std_logic;
		Sout	:	out std_logic;
		Cout:	out	std_logic
);
End;

Architecture behavior of full_adder is

Begin
-- Cin A  B  S  C
--  0  0  0  0  0
--  0  0  1  1  0
--  0  1  0  1  0
--  0  1  1  0  1
--  1  0  0  1  0
--  1  0  1  0  1
--  1  1  0  0  1
--  1  1  1  1  1

-- Full adder Logic find the expression in previous ppt

	Sout <= A xor B xor Cin;
	Cout <= (A and B) or ((A Xor B) and Cin);

	
End;

----------------------------------------------------------------------------------
-- VHDL CODE FOR MUX31:
----------------------------------------------------------------------------------

Library ieee;
Use ieee.std_logic_1164.all;
Use ieee.std_logic_unsigned.all;

entity MUX31 is
port(	Input1		:	in	std_logic;
		Input2		:	in	std_logic;
		Input3		:	in	std_logic;
		S			:	in	std_logic_vector(1 downto 0);
		Sout		:	out	std_logic);
end MUX31;

architecture Behavioral of MUX31 is

Begin
--MUX31 Logic (using When - ElSE structure)
	Sout <=	Input1 when S="00" else
				Input1 when S="01" else
				Input2 when S="10" else
				Input3 when S="11";


end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR and_gate:
----------------------------------------------------------------------------------

Library ieee;
Use ieee.std_logic_1164.all;
Use ieee.std_logic_unsigned.all;

Entity and_gate is
port(	
		In1		:	in	std_logic;
		In2		:	in	std_logic;
		Sout	:	out	std_logic
);
End;

Architecture behavior of and_gate is

Begin
-- In1  In2  Sout
--  0    0    0
--  0    1    0
--  1    0    0
--  1    1    1
	
-- and gate logic
	Sout <= In1 and In2;

End;

----------------------------------------------------------------------------------
-- VHDL CODE FOR or_gate:
----------------------------------------------------------------------------------

Library ieee;
Use ieee.std_logic_1164.all;
Use ieee.std_logic_unsigned.all;

Entity or_gate is
port(	
		In1		:	in	std_logic;
		In2		:	in	std_logic;
		Sout	:	out	std_logic
);
End;

Architecture behavior of or_gate is

Begin
-- In1  In2  Sout
--  0    0    0
--  0    1    1
--  1    0    1
--  1    1    1

-- or gate logic
	Sout <= In1 or In2;
End;

----------------------------------------------------------------------------------
-- VHDL CODE FOR Registers:
----------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;

Entity Registers is
	port(
		clk	:	in	 std_logic;
		clear	:	in  std_logic;
		
		a_addr:	in	 std_logic_vector( 3 downto 0);
		a_data:	in	 std_logic_vector(15 downto 0);
		load	:	in	 std_logic;
		
		b_addr:	in	 std_logic_vector( 3 downto 0);
		c_addr:	in	 std_logic_vector( 3 downto 0);
		
		b_data:	out std_logic_vector(15 downto 0);
		c_data:	out std_logic_vector(15 downto 0)
		);
End Registers;

architecture syn of Registers is
	type ram_type is array (15 downto 0) of std_logic_vector(15 downto 0);
	signal REG	:	ram_type;
begin
	process(clk, load, clear)
	begin
		if (clear = '0') then
			REG(0)	<= x"0000";
			REG(1)	<= x"0000";
			REG(2)	<= x"0000";
			REG(3)	<= x"0000";

			REG(4)	<= x"0000";
			REG(5)	<= x"0000";
			REG(6)	<= x"0000";
			REG(7)	<= x"0000";
		
			REG(8)	<= x"0000";
			REG(9)	<= x"0000";
			REG(10)	<= x"0000";
			REG(11)	<= x"0000";

			REG(12)	<= x"0000";
			REG(13)	<= x"0000";
			REG(14)	<= x"0000";
			REG(15)	<= x"0000";
		elsif (clk'event and clk='1') then
			if (load = '1') then
					REG(conv_integer(a_addr)) <= a_data;
			end if;
		end if;
		REG(0)	<= x"0000";
		REG(1)	<= x"0001";
	end process;
	b_data <= REG(conv_integer(b_addr));
	c_data <= REG(conv_integer(c_addr));
end syn;

--		if (clear = '0') then
--			for i in 15 downto 0 loop
--				REG(i) <= x"0000";
--			end loop;
--		elsif (rising_edge(clk) and load = '1') then
--			REG(conv_integer(a_addr)) <= a_data;
--		end if;		

----------------------------------------------------------------------------------
-- VHDL CODE FOR Control:
----------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;

Entity Control is
	port(
		op			:	in	std_logic_vector( 3 downto 0);
		alu_op		:	out	std_logic_vector( 1 downto 0);
		alu_src		:	out	std_logic;
		reg_dest	:	out	std_logic;
		reg_load	:	out	std_logic;
		reg_src		:	out	std_logic_vector(1 downto 0);
		mem_read	:	out	std_logic;
		mem_write	:	out	std_logic
		);
End Control;

architecture syn of Control is

begin
	process (op) is
	begin
		case op is

			-- op=0, ADD
			when x"0" =>
				alu_op		<=	"00";
				alu_src		<=	'0';
				reg_dest		<=	'0';
				reg_load		<=	'1';
				reg_src		<=	"01";
				mem_read		<=	'0';
				mem_write	<=	'0';

				-- TODO 1: Implement the subtraction
			-- op=1, SUB
			when x"1" =>
				alu_op		<=	"01";
				alu_src		<=	'0';
				reg_dest		<=	'0';
				reg_load		<=	'1';
				reg_src		<=	"01";
				mem_read		<=	'0';
				mem_write	<=	'0';

				-- TODO 2: Implement the AND
			-- op=2, AND
			when x"2" =>
				alu_op		<=	"10";
				alu_src		<=	'0';
				reg_dest		<=	'0';
				reg_load		<=	'1';
				reg_src		<=	"01";
				mem_read		<=	'0';
				mem_write	<=	'0';

				-- TODO 3: Implement the OR
			-- op=3, OR
			when x"3" =>
				alu_op		<=	"11";
				alu_src		<=	'0';
				reg_dest		<=	'0';
				reg_load		<=	'1';
				reg_src		<=	"01";
				mem_read		<=	'0';
				mem_write	<=	'0';

		  	-- TODO 4: Implement the addition immeadiate
			-- op=4, ADDi
			when x"4" =>
				alu_op		<=	"00";
				alu_src		<=	'1';
				reg_dest		<=	'X';
				reg_load		<=	'1';
				reg_src		<=	"01";
				mem_read		<=	'0';
				mem_write	<=	'0';

				-- TODO 5: Implement the subtraction immeadiate
			-- op=5, SUBi
			when x"5" =>
				alu_op		<=	"01";
				alu_src		<=	'1';
				reg_dest		<=	'X';
				reg_load		<=	'1';
				reg_src		<=	"01";
				mem_read		<=	'0';
				mem_write	<=	'0';

			-- op=8, LW
			when x"8" =>
				alu_op		<=	"00";
				alu_src		<=	'1';
				reg_dest		<=	'0';
				reg_load		<=	'1';
				reg_src		<=	"00";
				mem_read		<=	'1';
				mem_write	<=	'0';

				-- TODO 6: Implement the store word
			-- op=C, SW
			when x"C" =>
				alu_op		<=	"00";
				alu_src		<=	'1';
				reg_dest		<=	'1';
				reg_load		<=	'1';
				reg_src		<=	"01";
				mem_read		<=	'0';
				mem_write	<=	'0';

			-- op=7, SLT
			when x"7" =>
				alu_op		<= "11";
				alu_src		<= '0';
				reg_dest		<= '0';
				reg_load		<= '1';
				reg_src		<= "10";
				mem_read		<= '0';
				mem_write	<= '0';

			when others =>
				alu_op	<=	"00";
				alu_src	<=	'0';
				reg_dest	<=	'0';
				reg_load	<=	'0';
				reg_src	<=	"01";
				mem_read	<=	'0';
				mem_write<=	'0';

		end case;
	end process;
end syn;

----------------------------------------------------------------------------------
-- VHDL CODE FOR Signextend:
----------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;

Entity Signextend is
	port(
		immIn		:	in	std_logic_vector( 3 downto 0);
		immOut		:	out	std_logic_vector(15 downto 0)
		);
End Signextend;

architecture syn of Signextend is

begin

	-- TODO 1: Implement the immOut(5) - immOut(15) (HINT: Look at the signal immOut(3))
	immOut(3)	<=	immIn(3);
	immOut(2)	<=	immIn(2);
	immOut(1)	<=	immIn(1);
	immOut(0)	<=	immIn(0);
	process ( immIn)
	begin 
	if (immIn(3) = '1') then
	immOut(15 downto 4) <= "111111111111";
	else
	immOut(15 downto 4) <= "000000000000";
	end if;
	end process;

end syn;

----------------------------------------------------------------------------------
-- VHDL CODE FOR mux3_1:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity mux3_1 is
   generic (WIDTH : positive:=16);
	port(
		Input1		:	in		std_logic_vector(WIDTH-1 	downto 0);
		Input2		:	in		std_logic_vector(WIDTH-1 	downto 0);
		Input3		:	in		std_logic_vector(WIDTH-1 	downto 0);
		S				:	in		std_logic_vector(1 			downto 0);
		Sout			:	out	std_logic_vector(WIDTH-1 	downto 0));
end mux3_1;

architecture Behavioral of mux3_1 is

begin
	Sout <=	Input1 when S="00" else
				Input2 when S="01" else
				Input3 when S="10" else
				Input3 when S="11";
end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR mux2_1:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity mux2_1 is
   generic (WIDTH : positive:=16);
	port(
		Input1		:	in		std_logic_vector(WIDTH-1 	downto 0);
		Input2		:	in		std_logic_vector(WIDTH-1 	downto 0);
		S				:	in		std_logic;
		Sout			:	out	std_logic_vector(WIDTH-1 	downto 0));
end mux2_1;

architecture Behavioral of mux2_1 is

begin
	Sout <=	Input1 when S='0' else
				Input2 when S='1';
end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR TESTBENCH CPU_3380_Test:
----------------------------------------------------------------------------------

LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;

ENTITY CPU_3380_Test IS
END ENTITY CPU_3380_Test;

ARCHITECTURE mixed OF CPU_3380_Test IS
    CONSTANT  tick          : TIME := 100 ns;
    SIGNAL    reset, clock  : STD_LOGIC;
    SIGNAL    instruction   : STD_LOGIC_VECTOR(0 TO 15);

BEGIN
    CPU_3380_Sim : ENTITY work.CPU_3380
        port map(
            clk		      => clock,
            clear	      => reset,
            instruction => instruction
        );

    driver : PROCESS IS
    BEGIN
        -- reset the system
        reset <= '0'; instruction <= x"0000"; WAIT FOR 50 ns;
        reset <= '1';

        -- ADD r2, r1, r1
        instruction <= x"0211"; WAIT FOR tick;

        -- ADD r3, r2, r1
        instruction <= x"0321"; WAIT FOR tick;

        -- ADD r4, r3, r2
        instruction <= x"0432"; WAIT FOR tick;

        -- Sub r5, r4, r3
        instruction <= x"1543"; WAIT FOR tick;

        -- Sub r1, r5, r1
        instruction <= x"1151"; WAIT FOR tick;

        -- Sub r0, r3, r0
        instruction <= x"1030"; WAIT FOR tick;

		  -- And r6, r1, r1
        instruction <= x"2611"; WAIT FOR tick;

		  -- And r7, r3, r0
        instruction <= x"2730"; WAIT FOR tick;

 		  -- OR r8, r4, r1
        instruction <= x"3841"; WAIT FOR tick;
        
        --addi
        
        instruction <= x"4908"; WAIT FOR tick;
        
        
        --subi
        instruction <= x"5A08"; WAIT FOR tick;
        
        
        -- Lw
        instruction <= x"8B90"; WAIT FOR tick;
        
        
        --sw
        
        instruction <= x"CC30"; WAIT FOR tick;
        
        
        
        instruction <= x"7D12"; WAIT FOR tick;
        
        instruction <= x"7EA9"; WAIT FOR tick;
        
        WAIT;
    END PROCESS driver;

    clock_p : PROCESS IS
    BEGIN
        FOR i IN 0 TO 18 LOOP
            clock <= '1'; WAIT FOR  tick/2;
            clock <= '0'; WAIT FOR  tick/2;
        END LOOP;
        WAIT;
    END PROCESS clock_p;
END ARCHITECTURE mixed;

`
      },
      {
        id: "16_bit_alu",
        name: "CPU RTL Design: 16_Bit_ALU",
        summary: [
            "<u><b>Building Process</b></u>",
            "This project involved designing a hierarchical <b>16-bit Arithmetic Logic Unit (ALU)</b> in <b>VHDL</b>, built from modular components such as <b>1-bit ALUs</b>, <b>full adders</b>, <b>logic gates</b>, <b>comparators</b>, and an <b>8-to-1 multiplexer</b>. The ALU supported multiple arithmetic and logic operations including addition, subtraction, AND, OR, XOR, set-less-than (SLT), and branch-equal (BEQ), while also generating <b>Zero</b> and <b>Overflow</b> flags. The design was implemented in <b>Xilinx ISE</b>, validated through a comprehensive <b>test bench</b>, and simulated to verify correct operation across all instruction codes before FPGA deployment.",
            "<u><b>Project Impact</b></u>",
            "This project strengthened expertise in <b>CPU RTL design</b> and <b>modular VHDL architecture</b>, highlighting how complex arithmetic units are constructed hierarchically from smaller building blocks. It provided hands-on experience in <b>flag generation</b> (Zero, Overflow), <b>control signal decoding</b>, and <b>operation multiplexing</b>, which are foundational to processor datapaths. The project also enhanced skills in test bench development, debugging timing-sensitive hardware, and mapping arithmetic logic onto FPGA fabric â€” bridging the gap between <b>theoretical ALU design</b> and <b>practical hardware implementation</b>.",
            "<u><b>Key Skills:</b></u> VHDL | CPU RTL Design | Hierarchical Design | ALU Implementation | Arithmetic & Logic Operations | Multiplexer-Based Control | Flag Generation (Zero, Overflow) | Xilinx ISE | FPGA | Modular Design | Test Bench Development | Hardware Simulation & Verification"
        ],
        images: ["assets/CO_L2_1.png"],
        videos: [],
        downloads: ["downloads/CO_L2.zip"],
        links: [{ label: "GitHub Repository", url: "https://github.com/Aamir-Ir/VHDL_Achievements/tree/main/VHDL%20-%20Advanced/ALU"}],
        code: `-- VHDL SOURCE CODE FILE FOR 16-BIT ALU (CO_L2):
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.std_logic_unsigned;
use IEEE.NUMERIC_STD.ALL;

entity FinalALU is
generic (Dwidth : integer :=8);
 Port (
    IN1, IN2 : in std_logic_vector (Dwidth-1 downto 0);
    SEL : in std_logic_vector (2 downto 0);
    Cin : in std_logic;
    ALU_OUT : out std_logic_vector(Dwidth-1 downto 0);
    Zero, OVF : out std_logic
  );
end FinalALU;

architecture Behavioral of FinalALU is
component SingleFinalALU is
port(	
		A	:	in	std_logic;
		B	:	in	std_logic;
		Cin	:	in	std_logic;
		S	:	in	std_logic_vector(2 downto 0);
		alu_out:	out std_logic;
		Cout:	out	std_logic;
		OVF : out std_logic;
		zero : out std_logic
);
end component;
signal equal : std_logic_vector (Dwidth-1 downto 0);
signal carry : std_logic_vector (Dwidth-1 downto 0);
signal overflow : std_logic_vector (Dwidth-1 downto 0);
begin
alu01	:	SingleFinalALU	port map(IN1(0),		IN2(0),		SEL(0),			    SEL ,	ALU_OUT(0),		carry(0), overflow (0),equal(0));
alu02	:	SingleFinalALU	port map(IN1(1),		IN2(1),		carry(0),			SEL ,	ALU_OUT(1),		carry(1), overflow (1),equal(1));
alu03	:	SingleFinalALU	port map(IN1(2),		IN2(2),		carry(1),			SEL ,	ALU_OUT(2),		carry(2), overflow (2),equal(2));
alu04	:	SingleFinalALU	port map(IN1(3),		IN2(3),		carry(2),			SEL ,	ALU_OUT(3),		carry(3), overflow (3),equal(3));
alu05	:	SingleFinalALU	port map(IN1(4),		IN2(4),		carry(3),			SEL ,	ALU_OUT(4),		carry(4), overflow (4),equal(4));
alu06	:	SingleFinalALU	port map(IN1(5),		IN2(5),		carry(4),			SEL ,	ALU_OUT(5),		carry(5), overflow (5),equal(5));
alu07	:	SingleFinalALU	port map(IN1(6),		IN2(6),		carry(5),			SEL ,	ALU_OUT(6),		carry(6), overflow (6),equal(6));
alu08	:	SingleFinalALU	port map(IN1(7),		IN2(7),		carry(6),			SEL ,	ALU_OUT(7),		carry(7), overflow (7),equal(7));
OVF <= overflow(7);
Zero <= equal(0) and equal(1) and equal(2) and equal(3) and equal(4) and equal(5) and equal(6) AND equal(7);

end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR SingleFinalALU:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity SingleFinalALU is
port(	
		A	:	in	std_logic;
		B	:	in	std_logic;
		Cin	:	in	std_logic;
		S	:	in	std_logic_vector(2 downto 0);
		alu_out:	out std_logic;
		Cout:	out	std_logic;
		OVF : out std_logic;
		zero : out std_logic
);
end SingleFinalALU;

architecture Behavioral of SingleFinalALU is
    COMPONENT full_adder
	port(	
		A	:	in	std_logic;
		B	:	in	std_logic;
		Cin	:	in	std_logic;
		Sout	:	out std_logic;
		Cout:	out	std_logic
		);
    END COMPONENT;
	component beq is
    port(	
            In1		:	in	std_logic;
            In2		:	in	std_logic;
            Sout	:	out	std_logic
    );
    End component;
	component MUX81
	port(	
        Input1		:	in	std_logic;
		Input2		:	in	std_logic;
		Input3		:	in	std_logic;
		Input4		:	in	std_logic;
		Input5		:	in	std_logic;
		Input7		:	in	std_logic;
		Input8		:	in	std_logic;
		S			:	in	std_logic_vector(2 downto 0);
		Sout		:	out	std_logic
		);
	end component;
	
	component and_gate
	port(	
		In1		:	in	std_logic;
		In2		:	in	std_logic;
		Sout	:	out	std_logic
		);
	end component;
	component slt	
	port(	
		In1		:	in	std_logic;
		In2		:	in	std_logic;
		Sout	:	out	std_logic
    );
    end component;
	component or_gate
	port(	
		In1		:	in	std_logic;
		In2		:	in	std_logic;
		Sout	:	out	std_logic
		);
	end component;
	component xor_gate
	port(	
		In1		:	in	std_logic;
		In2		:	in	std_logic;
		Sout	:	out	std_logic
		);
	end component;
	component unsigned_adder
	port (
	   	A	:	in	std_logic;
		B	:	in	std_logic;
		Cin	:	in	std_logic;
		Sout	:	out std_logic;
		Cout:	out	std_logic;
		OVF : out std_logic
	);
	end component;
	
--Signals Defination
	signal Sout_full_adder	:	std_logic;
	signal Sout_unsigned_adder : std_logic;
	signal Sout_or_gate		:	std_logic;
	signal Sout_and_gate		:	std_logic;
	signal Sout_xor_gate   : std_logic;
	signal Sout_slt: std_logic;
	signal Sout_beq : std_logic;
	signal NB					:	std_logic;
Begin

	NB <= B xor S(0);
	
	C1:full_adder	port map(
		A		=>	A,
		B		=>	NB,
		Cin	=>	Cin,
		Sout	=>	Sout_full_adder,
		Cout	=>	Cout
	);

	C2:and_gate	port map(
		In1	=>	A,
		In2	=> B,
		Sout	=> Sout_and_gate
	);
	
	C3:or_gate		port map(
		In1	=>	A,
		In2	=>	B,
		Sout	=>	Sout_or_gate
	);
	
	C4:MUX81		port map(
		Input1	=>	Sout_and_gate,
		Input2	=>	Sout_or_gate,
		Input3	=>	Sout_unsigned_adder,
		Input4 =>   Sout_xor_gate,
		Input5 =>  Sout_full_adder,
		Input7 =>   Sout_slt,
		Input8 => Sout_beq,
		S			=>	S,
		Sout		=>	alu_out
	);
    C5 : xor_gate port map(
		In1	=>	A,
		In2	=>	B,
		Sout	=>	Sout_xor_gate
	);
	C6 : slt port map(
		In1	=>	A,
		In2	=>	B,
		Sout	=>	Sout_slt
	);
	C7 : beq port map(
		In1	=>	A,
		In2	=>	B,
		Sout	=>	Sout_beq
	);
	C8 : unsigned_adder port map
	(
		A		=>	A,
		B		=>	B,
		Cin	=>	Cin,
		Sout	=>	Sout_unsigned_adder,
		Cout	=>	Cout,
	    OVF => OVF
	);
	zero <= Sout_beq;
end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR and_gate
----------------------------------------------------------------------------------

Library ieee;
Use ieee.std_logic_1164.all;
Use ieee.std_logic_unsigned.all;

Entity and_gate is
port(	
		In1		:	in	std_logic;
		In2		:	in	std_logic;
		Sout	:	out	std_logic
);
End;

Architecture behavior of and_gate is

Begin
-- In1  In2  Sout
--  0    0    0
--  0    1    0
--  1    0    0
--  1    1    1
	
-- and gate logic
	Sout <= In1 and In2;

End;

----------------------------------------------------------------------------------
-- VHDL CODE FOR or_gate
----------------------------------------------------------------------------------

Library ieee;
Use ieee.std_logic_1164.all;
Use ieee.std_logic_unsigned.all;

Entity or_gate is
port(	
		In1		:	in	std_logic;
		In2		:	in	std_logic;
		Sout	:	out	std_logic
);
End;

Architecture behavior of or_gate is

Begin
-- In1  In2  Sout
--  0    0    0
--  0    1    1
--  1    0    1
--  1    1    1

-- or gate logic
	Sout <= In1 or In2;
End;

----------------------------------------------------------------------------------
-- VHDL CODE FOR full_adder
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity full_adder is
    Port (
        A     : in  STD_LOGIC;
        B     : in  STD_LOGIC;
        Cin   : in  STD_LOGIC;
        Sout  : out STD_LOGIC;
        Cout  : out STD_LOGIC
    );
end full_adder;

architecture Behavioral of full_adder is
begin
    Sout <= A XOR B XOR Cin;
    Cout <= (A AND B) OR (B AND Cin) OR (A AND Cin);
end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR and_gate
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity and_gate is
    Port (
        In1   : in  STD_LOGIC;
        In2   : in  STD_LOGIC;
        Sout  : out STD_LOGIC
    );
end and_gate;

architecture Behavioral of and_gate is
begin
    Sout <= In1 AND In2;
end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR or_gate
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity or_gate is
    Port (
        In1   : in  STD_LOGIC;
        In2   : in  STD_LOGIC;
        Sout  : out STD_LOGIC
    );
end or_gate;

architecture Behavioral of or_gate is
begin
    Sout <= In1 OR In2;
end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR MUX81:
----------------------------------------------------------------------------------

Library ieee;
Use ieee.std_logic_1164.all;
Use ieee.std_logic_unsigned.all;

entity MUX81 is
port(	
        Input1		:	in	std_logic;
		Input2		:	in	std_logic;
		Input3		:	in	std_logic;
		Input4		:	in	std_logic;
		Input5		:	in	std_logic;
		Input7		:	in	std_logic;
		Input8		:	in	std_logic;
		S			:	in	std_logic_vector(2 downto 0);
		Sout		:	out	std_logic);
end MUX81;

architecture Behavioral of MUX81 is

Begin
--MUX81 Logic (using When - ElSE structure)
	Sout <=	Input1 when S="000" else
				Input2 when S="001" else
				Input3 when S="010" else
				Input4 when S="011" else
				Input5 when S="100" else
				Input5 when S = "101" else
				Input7 when S= "110" else
				Input8 when s = "111";


end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR xor_gate:
----------------------------------------------------------------------------------

Library ieee;
Use ieee.std_logic_1164.all;
Use ieee.std_logic_unsigned.all;

Entity xor_gate is
port(	
		In1		:	in	std_logic;
		In2		:	in	std_logic;
		Sout	:	out	std_logic
);
End;

Architecture behavior of xor_gate is

Begin
-- In1  In2  Sout
--  0    0    0
--  0    1    0
--  1    0    0
--  1    1    1
	
-- and gate logic
	Sout <= In1 xor In2;

End;

----------------------------------------------------------------------------------
-- VHDL CODE FOR slt:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity slt is
 Port ( 
 		In1		:	in	std_logic;
		In2		:	in	std_logic;
		Sout	:	out	std_logic
		);
end slt;

architecture Behavioral of slt is

begin
--  A  B  S 
--  0  0  0 
--  0  1  1 
--  1  0  0 
--  1  1  0 

Sout <= (not In1) and In2;

end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR beq:
----------------------------------------------------------------------------------

Library ieee;
Use ieee.std_logic_1164.all;
Use ieee.std_logic_unsigned.all;

Entity beq is
port(	
		In1		:	in	std_logic;
		In2		:	in	std_logic;
		Sout	:	out	std_logic
);
End;

Architecture behavior of beq is

Begin
-- In1  In2  Sout
--  0    0    1
--  0    1    0
--  1    0    0
--  1    1    1
	
-- and gate logic
	Sout <=  (In1 and In2) or ((not In1) and (not In2));

End;

----------------------------------------------------------------------------------
-- VHDL CODE FOR signed_adder:
----------------------------------------------------------------------------------

Library ieee;
Use ieee.std_logic_1164.all;
Use ieee.std_logic_unsigned.all;

Entity unsigned_adder is
port(	
		A	:	in	std_logic;
		B	:	in	std_logic;
		Cin	:	in	std_logic;
		Sout	:	out std_logic;
		Cout:	out	std_logic;
		OVF : out std_logic
);
End;

Architecture behavior of unsigned_adder is

Begin


	Sout <= A xor B xor Cin;
	Cout <= (A and B) or ((A Xor B) and Cin);
	OVF <= Cin xor ((A and B) or ((A Xor B) and Cin));

	
End;

----------------------------------------------------------------------------------
-- VHDL CODE FOR alu1bit:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
use ieee.NUMERIC_STD.all;

entity alu1bit is
generic (Dwidth : integer :=8);
 Port (
    IN1, IN2 : in std_logic_vector (Dwidth-1 downto 0);
    SEL : in std_logic_vector (2 downto 0);
    Cin : in std_logic;
    ALU_OUT : out std_logic_vector(Dwidth-1 downto 0);
    Zero, OVF : out std_logic
    );
end alu1bit;

architecture Behavioral of alu1bit is
signal result : std_logic_vector(Dwidth-1 downto 0);
signal overflow :std_logic;
signal eq : std_logic;
begin
process(IN1,IN2,SEL, Cin)
begin
overflow <= '0';
if (IN1 = IN2) then
eq <= '1';
else
eq <= '0';
end if;
case (SEL) is 
when "000" =>
result <= IN1 and IN2;
when "001" =>
result <= IN1 or IN2;
when "010" =>
result <= std_logic_vector(unsigned(IN1)+ unsigned(IN2));
when "011" =>
result <= IN1 xor IN2;
when "100" =>
result <= std_logic_vector(signed(IN1) + signed(IN2));
if IN1(7) = '0' AND IN2(7) = '0' AND result(7) = '1' then
    overflow <= '1'; 
elsif  IN1(7) = '1' AND IN2(7) = '1' AND result(7) = '0' then
    overflow <='1';
else
    overflow <='0';
end if;
when "101" =>
result <= std_logic_vector(signed(IN1) - signed(IN2));
if IN1(7) = '0' AND IN2(7) = '0' AND result(7) = '1' then
    overflow <= '1'; 
elsif  IN1(7) = '1' AND IN2(7) = '1' AND result(7) = '0' then
    overflow <='1';
else
    overflow <='0';
end if;
when "110" =>
if (IN1 < IN2) then
result <= x"01";
else 
result <= x"00";
end if;
when "111" =>
if (IN1 = IN2) then
result <= x"01";
else
result <= x"00";
end if;
when others =>
result <= IN1 + IN2;
end case;
end process;
ALU_OUT <= result;
OVF <= overflow;
Zero <= eq;
end Behavioral;

----------------------------------------------------------------------------------
-- VHDL TEST BENCH CODE FinalALU_test:
----------------------------------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.std_logic_unsigned.all;
USE ieee.numeric_std.ALL;

ENTITY FinalALU_test IS
END FinalALU_test;
 
ARCHITECTURE behavior OF FinalALU_test IS 
 
    -- Component Declaration for the Unit Under Test (UUT)

    COMPONENT alu1bit
    generic (Dwidth : integer :=8);
     Port (
        IN1, IN2 : in std_logic_vector (Dwidth-1 downto 0);
        SEL : in std_logic_vector (2 downto 0);
        Cin : in std_logic;
        ALU_OUT : out std_logic_vector(Dwidth-1 downto 0);
        Zero, OVF : out std_logic
      );
	END COMPONENT;

   --Inputs
   signal IN1 	: std_logic_vector(7 downto 0) := x"00";
   signal IN2 	: std_logic_vector(7 downto 0) := x"00";
   signal Cin 	: std_logic := '0';
   signal SEL		: std_logic_vector(2 downto 0);
   signal ALU_OUT :  std_logic_vector(7 downto 0);
   signal Zero : std_logic;
   signal OVF : std_logic;

   
BEGIN
 
	-- Instantiate the Unit Under Test (UUT)
   uut: alu1bit PORT MAP (
            IN1 => IN1,
            IN2 => IN2,
            SEL => SEL,
            Cin => Cin,
            ALU_OUT => ALU_OUT,
            Zero => Zero,
            OVF => OVF
        );

   -- Stimulus process
   stim_proc: process
   begin		
		IN1		<=	x"04";	-- 
		IN2		<=	x"FE";	-- 
		Cin	<=	'0';
		SEL		<=	"100";		-- Add
		wait for 10 ns;	
		IN1		<=	x"FF";	-- 
		IN2		<=	x"09";	-- 
		Cin	<=	'0';
		SEL		<=	"100";		-- Add
		wait for 10 ns;	
		IN1		<=	x"04";	-- 6
		IN2		<=	x"FE";	-- 6
		Cin	<=	'0';
		SEL		<=	"010";		-- unsigned add
		wait for 10 ns;	
		IN1		<=	x"04";	-- 
		IN2		<=	x"06";	-- 
		Cin	<=	'0';
		SEL		<=	"101";		-- subtract
		wait for 10 ns;		
		IN1		<=	x"04";	-- 
		IN2		<=	x"06";	-- 
		SEL		<=	"000";		-- and
		wait for 10 ns;
		IN1		<=	x"06";	-- 
		IN2		<=	x"06";	-- 
		SEL		<=	"000";		-- and
		wait for 10 ns;	
		IN1		<=	x"04";	-- 
		IN2		<=	x"06";	-- 
		SEL		<=	"001";		-- or
		wait for 10 ns;
		IN1		<=	x"06";	-- 
		IN2		<=	x"06";	-- 
		SEL		<=	"001";		-- or
		wait for 10 ns;	
		IN1		<=	x"06";	-- 
		IN2		<=	x"06";	-- 
		SEL		<=	"011";		-- xor
		wait for 10 ns;	
		IN1		<=	x"03";	-- 
		IN2		<=	x"06";	-- 
		SEL		<=	"110";		-- slt
		wait for 10 ns;
		IN1		<=	x"06";	-- 
		IN2		<=	x"06";	-- 
		SEL		<=	"111";		-- beq
		wait for 10 ns;	
		wait;
   end process;

END;`
      },
      {
        id: "Reg_Mem",
        name: "Register/Memory",
        summary: [
            "<u><b>Building Process</b></u>",
            "This project focused on designing and testing <b>memory systems</b> and a <b>register file</b> in <b>VHDL</b>. Multiple memory modes were implemented, including <b>Write-First</b>, <b>Read-First</b>, and <b>No-Change</b>, along with a <b>Register File</b> supporting simultaneous read and write operations. The designs were validated through <b>test benches</b> and simulated to ensure correct timing and data consistency. Outputs were connected to a <b>7-Segment Display</b> for visualization, and the system was deployed on an <b>FPGA board</b> using <b>Xilinx ISE</b>.",
            "<u><b>Project Impact</b></u>",
            "Unlike the <b>SIMD CPU project</b>, which emphasized computation and instruction execution, this project concentrated on the <b>storage and retrieval aspects</b> of digital systems. It deepened understanding of <b>memory architectures</b>, <b>register file design</b>, and <b>FPGA-based data storage</b>. The project demonstrated how memory modes affect data availability and hardware timing, while also reinforcing skills in <b>hierarchical VHDL design</b>, <b>modular coding</b>, and <b>simulation-driven debugging</b>. These skills are crucial for bridging the gap between <b>processing units</b> and <b>memory subsystems</b> in computer architecture.",
            "<u><b>Key Skills:</b></u> VHDL | Memory Architectures (Write-First, Read-First, No-Change) | Register File Design | Hierarchical Design | Xilinx ISE | FPGA | 7-Segment Display | Modular Design | Test Bench Development | Hardware Simulation & Verification"
        ],
        images: ["assets/CO_L1_1.png", "assets/CO_L1_2.png", "assets/CO_L1_3.png"],
        videos: [],
        downloads: ["downloads/CO_L1.zip"],
        links: [{ label: "GitHub Repository", url: "https://github.com/Aamir-Ir/VHDL_Achievements/tree/main/VHDL%20-%20Advanced/Different%20Memory%20Configurations/Sources"}],
        code: `-- VHDL SOURCE CODE FILE FOR TESTING DIFFERENT MEMORY CONFIGURATIONS (CO_L1):
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity lab2mem is 
    generic ( Dwidth : integer := 16; -- Each location is 16 bits
              Awidth : integer := 8); -- 8 Address lines (i.e., 64 locations)
    port ( we,clk: in std_logic;
           addr: in std_logic_vector(Awidth-1 downto 0);
           din: in std_logic_vector(Dwidth-1 downto 0);
           dout: out std_logic_vector(Dwidth-1 downto 0) );
end lab2mem;

architecture Behavioural of lab2mem is
type memType is array(0 to 2**Awidth-1) of std_logic_vector(Dwidth-1 downto 0);

-- The first 8 locations are initialized, the rest set to 0.
signal memory: memType:= ( "0000000000000001",
                           "0000000000000010",
                           "0000000000000100",
                           "0000000000001000",
                           "0000000000010000",
                           "0000000000100000",
                           "0000000001000000",
                           "0000000010000000",
                        others=> "0000000000000000" ); 

attribute ram_style: string;
attribute ram_style of memory : signal is "block";
                        
begin
    process(clk)
    begin
        if(clk'event and clk='1') then            
            if(we='1') then
                memory(conv_integer(addr)) <= din; 
                dout <= din; 
            else
                dout <= memory(conv_integer(addr)); 
            end if; 
        end if; 
    end process;
end Behavioural;      

----------------------------------------------------------------------------------
-- VHDL CODE FOR MEMORY IMPLEMENTATION:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity memoryimplementation is
    Port ( address : in STD_LOGIC_VECTOR (7 downto 0);
            clock : in STD_LOGIC;
           ssd : out STD_LOGIC_VECTOR (6 downto 0);
           n1,n2,n3,n4,n5,n6,n7 : out STD_LOGIC
            );
end memoryimplementation;
architecture Behavioral of memoryimplementation is

COMPONENT writefirst
    generic ( Dwidth : integer := 16; -- Each location is 16 bits
              Awidth : integer := 8); -- 8 Address lines (i.e., 64 locations)
    port ( we,clk: in std_logic;
           addr: in std_logic_vector(Awidth-1 downto 0);
           din: in std_logic_vector(Dwidth-1 downto 0);
           dout: out std_logic_vector(Dwidth-1 downto 0) );
END COMPONENT;
signal input : std_logic_vector (15 downto 0);
signal output : std_logic_vector (15 downto 0);
begin

mymem : writefirst
    generic map(16,8)
    port map(
    we => '0',
    clk => clock,
    addr => address,
    din => input,
    dout => output
    );
    
n1<='1';
n2<='1';
n3<='1';
n4<='1';
n5<='1';
n6<='1';
n7<='1';


ssd <= "1000000" when output="0000000000000000" else ---0
"1111001" when output="0000000000000001" else ---1
"0100100" when output="0000000000000010" else ---2
"0011001" when output="0000000000000100" else ---4
"0000000" when output="0000000000001000" else ---8
"1111111";

end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR REGFILE:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity regfile is
    generic (
    Dwidth : integer := 16;
    Awidth : integer :=4);
    port (
    ReadA1, ReadA2, WriteA : in std_logic_vector (Awidth-1 downto 0);
    Data01, Data02 : out std_logic_vector (Dwidth-1 downto 0);
    DataIn : in std_logic_vector (Dwidth-1 downto 0);
    WE,CLK : in std_logic);
end regfile;

architecture Behavioral of regfile is
    type registerFile is array(0 to 2**Awidth-1) of std_logic_vector(Dwidth-1 downto 0);
    signal memory: registerFile:= ( "0000000000000001",
                           "0000000000000010",
                           "0000000000000100",
                           "0000000000001000",
                           "0000000000010000",
                           "0000000000100000",
                           "0000000001000000",
                           "0000000010000000",
                        others=> "0000000000000000" ); 

attribute ram_style: string;
attribute ram_style of memory : signal is "block";
begin
regFile : process (clk) is
begin

    if rising_edge(clk) then
      Data01 <= memory(conv_integer(unsigned(ReadA1)));
      Data02 <= memory(conv_integer(unsigned(ReadA2)));
      if WE = '1' then
        memory(conv_integer(unsigned(WriteA))) <= DataIn; 
        if ReadA1 = WriteA then
          Data01 <= DataIn;
        end if;
        if ReadA2 = WriteA then
          Data02 <= DataIn;
        end if;
      end if;
    end if;
  end process;
end behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR REGFILE_TB:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity regfile_tb is
end regfile_tb;

architecture Behavioral of regfile_tb is
 component regfile
      generic (
      Dwidth : integer := 16;
      Awidth : integer := 4);
     
      port (
      ReadA1, ReadA2, WriteA : in std_logic_vector (Awidth-1 downto 0);
      Data01, Data02 : out std_logic_vector (Dwidth-1 downto 0);
      DataIn : in std_logic_vector (Dwidth-1 downto 0);
      WE,CLK : in std_logic);
  end component;
 
      signal ReadA1, ReadA2, WriteA : std_logic_vector (3 downto 0);
      signal Data01, Data02 : std_logic_vector (15 downto 0);
      signal DataIn : std_logic_vector (15 downto 0);
      signal WE,CLK : std_logic;
  
  
begin

uut : regfile 
    generic map(16,4)
    port map(
    WE => WE,
    CLK => CLK,
    DataIn => DataIn,
    ReadA1 => ReadA1,
    ReadA2 => ReadA2,
    WriteA => WriteA,
    Data01 => Data01,
    Data02 => Data02
    );
stim_proc : process
begin

CLK<='0';
WE <= '0';
DataIn <="0000000000000000";
ReadA1 <="0000";
ReadA2 <="0000";
WriteA <="0000";

wait for 100 ns;

CLK<='1';

wait for 100 ns;

CLK<='0';

wait for 100 ns;

ReadA1 <= "0001";
ReadA2 <= "0010";
CLK<='1';

wait for 100 ns;

CLK<='0';

wait for 100 ns;

WE<='1';
DataIn <= "0000000000001000";
WriteA<= "0001";
CLK <='1';

wait for 100 ns;

CLK<='0';

wait for 100 ns;

WE<='0';
CLK<='1';



wait;
end process;
end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR READFIRST:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity readfirst is 
    generic ( Dwidth : integer := 16; -- Each location is 16 bits
              Awidth : integer := 8); -- 8 Address lines (i.e., 64 locations)
    port ( we,clk: in std_logic;
           addr: in std_logic_vector(Awidth-1 downto 0);
           din: in std_logic_vector(Dwidth-1 downto 0);
           dout: out std_logic_vector(Dwidth-1 downto 0) );
end readfirst;

architecture Behavioural of readfirst is
type memType is array(0 to 2**Awidth-1) of std_logic_vector(Dwidth-1 downto 0);

-- The first 8 locations are initialized, the rest set to 0.
signal memory: memType:= ( "0000000000000001",
                           "0000000000000010",
                           "0000000000000100",
                           "0000000000001000",
                           "0000000000010000",
                           "0000000000100000",
                           "0000000001000000",
                           "0000000010000000",
                        others=> "0000000000000000" ); 

attribute ram_style: string;
attribute ram_style of memory : signal is "block";
                        
begin
    process(clk)
    begin
        if(rising_edge(clk)) then            
            if(we='1') then
                memory(conv_integer(addr)) <= din; 
            end if;
                dout <= memory(conv_integer(addr)); 
            end if; 
    end process;
end Behavioural;      

----------------------------------------------------------------------------------
-- VHDL CODE FOR READFIRST_TB:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity readfirst_tb is
end readfirst_tb;

architecture Behavioral of readfirst_tb is

COMPONENT readfirst
    generic ( Dwidth : integer := 16; -- Each location is 16 bits
              Awidth : integer := 8); -- 8 Address lines (i.e., 64 locations)
    port ( we,clk: in std_logic;
           addr: in std_logic_vector(Awidth-1 downto 0);
           din: in std_logic_vector(Dwidth-1 downto 0);
           dout: out std_logic_vector(Dwidth-1 downto 0) );
END COMPONENT;

signal we : std_logic := '0';
signal clk :std_logic := '0';
signal addr: std_logic_vector(7 downto 0);
signal din: std_logic_vector(15 downto 0);
signal dout: std_logic_vector(15 downto 0);

begin

uut : readfirst 
    generic map(16,8)
    port map(
    we => we,
    clk => clk,
    addr => addr,
    din => din,
    dout => dout
    );
stim_proc : process
begin

clk<='0';
we <= '0';
din <="0000000000000000";
addr <="00000000";

wait for 100 ns;

clk<='1';
we <= '0';
din <="0000000000000000";
addr <="00000001";

wait for 100 ns;

clk<='0';

wait for 100 ns;

clk<='1';
we <= '1';
din <="0000000000000100";
addr <="00000001";

wait for 100 ns;

clk<='0';

wait for 100 ns;

clk<='1';
we <= '1';
din <="0000000000001000";
addr <="00000010";

wait for 100 ns;

clk<='0';

wait for 100 ns;

clk<='1';
we <= '0';
din <="0000000000000000";
addr <="00000001";



wait;

end process;
end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR NOCHANGE:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity nochange is 
    generic ( Dwidth : integer := 16; -- Each location is 16 bits
              Awidth : integer := 8); -- 8 Address lines (i.e., 64 locations)
    port ( we,clk: in std_logic;
           addr: in std_logic_vector(Awidth-1 downto 0);
           din: in std_logic_vector(Dwidth-1 downto 0);
           dout: out std_logic_vector(Dwidth-1 downto 0) );
end nochange;

architecture Behavioural of nochange is
type memType is array(0 to 2**Awidth-1) of std_logic_vector(Dwidth-1 downto 0);

-- The first 8 locations are initialized, the rest set to 0.
signal memory: memType:= ( "0000000000000001",
                           "0000000000000010",
                           "0000000000000100",
                           "0000000000001000",
                           "0000000000010000",
                           "0000000000100000",
                           "0000000001000000",
                           "0000000010000000",
                        others=> "0000000000000000" ); 

attribute ram_style: string;
attribute ram_style of memory : signal is "block";
                        
begin
    process(clk)
    begin
        if(rising_edge(clk)) then            
            if(we='1') then
                memory(conv_integer(addr)) <= din; 
            else
                dout <= memory(conv_integer(addr)); 
            end if; 
        end if; 
    end process;
end Behavioural;      

----------------------------------------------------------------------------------
-- VHDL CODE FOR NOCHANGE_TB:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity nochange_tb is
end nochange_tb;

architecture Behavioral of nochange_tb is

COMPONENT nochange
    generic ( Dwidth : integer := 16; -- Each location is 16 bits
              Awidth : integer := 8); -- 8 Address lines (i.e., 64 locations)
    port ( we,clk: in std_logic;
           addr: in std_logic_vector(Awidth-1 downto 0);
           din: in std_logic_vector(Dwidth-1 downto 0);
           dout: out std_logic_vector(Dwidth-1 downto 0) );
END COMPONENT;

signal we : std_logic := '0';
signal clk :std_logic := '0';
signal addr: std_logic_vector(7 downto 0);
signal din: std_logic_vector(15 downto 0);
signal dout: std_logic_vector(15 downto 0);

begin

uut : nochange 
    generic map(16,8)
    port map(
    we => we,
    clk => clk,
    addr => addr,
    din => din,
    dout => dout
    );
stim_proc : process
begin


clk<='0';
we <= '0';
din <="0000000000000000";
addr <="00000000";

wait for 100 ns;

clk<='1';
we <= '0';
din <="0000000000000000";
addr <="00000001";

wait for 100 ns;

clk<='0';

wait for 100 ns;

clk<='1';
we <= '1';
din <="0000000000000100";
addr <="00000001";

wait for 100 ns;

clk<='0';

wait for 100 ns;

clk<='1';
we <= '1';
din <="0000000000001000";
addr <="00000010";

wait for 100 ns;

clk<='0';

wait for 100 ns;

clk<='1';
we <= '0';
din <="0000000000000000";
addr <="00000001";



wait;
end process;
end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR WRITEFIRST:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity writefirst is 
    generic ( Dwidth : integer := 16; -- Each location is 16 bits
              Awidth : integer := 8); -- 8 Address lines (i.e., 64 locations)
    port ( we,clk: in std_logic;
           addr: in std_logic_vector(Awidth-1 downto 0);
           din: in std_logic_vector(Dwidth-1 downto 0);
           dout: out std_logic_vector(Dwidth-1 downto 0) );
end writefirst;

architecture Behavioural of writefirst is
type memType is array(0 to 2**Awidth-1) of std_logic_vector(Dwidth-1 downto 0);

-- The first 8 locations are initialized, the rest set to 0.
signal memory: memType:= ( "0000000000000001",
                           "0000000000000010",
                           "0000000000000100",
                           "0000000000001000",
                           "0000000000010000",
                           "0000000000100000",
                           "0000000001000000",
                           "0000000010000000",
                        others=> "0000000000000000" ); 

attribute ram_style: string;
attribute ram_style of memory : signal is "block";
                        
begin
    process(clk)
    begin
        if(rising_edge(clk)) then            
            if(we='1') then
                memory(conv_integer(addr)) <= din; 
                dout <= din; 
            else
                dout <= memory(conv_integer(addr)); 
            end if; 
        end if; 
    end process;
end Behavioural;      

----------------------------------------------------------------------------------
-- VHDL CODE FOR WRITEFIRST_TB:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity writefirst_tb is
end writefirst_tb;

architecture Behavioral of writefirst_tb is

COMPONENT writefirst
    generic ( Dwidth : integer := 16; -- Each location is 16 bits
              Awidth : integer := 8); -- 8 Address lines (i.e., 64 locations)
    port ( we,clk: in std_logic;
           addr: in std_logic_vector(Awidth-1 downto 0);
           din: in std_logic_vector(Dwidth-1 downto 0);
           dout: out std_logic_vector(Dwidth-1 downto 0) );
END COMPONENT;

signal we : std_logic := '0';
signal clk :std_logic := '0';
signal addr: std_logic_vector(7 downto 0);
signal din: std_logic_vector(15 downto 0);
signal dout: std_logic_vector(15 downto 0);

begin

uut : writefirst 
    generic map(16,8)
    port map(
    we => we,
    clk => clk,
    addr => addr,
    din => din,
    dout => dout
    );
stim_proc : process
begin

clk<='0';
we <= '0';
din <="0000000000000000";
addr <="00000000";

wait for 100 ns;

clk<='1';
we <= '0';
din <="0000000000000000";
addr <="00000001";

wait for 100 ns;

clk<='0';

wait for 100 ns;

clk<='1';
we <= '1';
din <="0000000000000100";
addr <="00000001";

wait for 100 ns;

clk<='0';

wait for 100 ns;

clk<='1';
we <= '1';
din <="0000000000001000";
addr <="00000010";

wait for 100 ns;

clk<='0';

wait for 100 ns;

clk<='1';
we <= '0';
din <="0000000000000000";
addr <="00000001";



wait;

end process;
end Behavioral;

`
      },
      {
        id: "SIMD_CPU",
        name: "CPU (SIMD)",
        summary: [
        "<u><b>Building Process</b></u>",
        "This project involved designing a <b>CPU with SIMD architecture</b> in <b>VHDL</b>, integrating a <b>Control Unit</b>, <b>Register Files</b>, and <b>Arithmetic Units (AUs)</b> for parallel computation. A debouncer module ensured stable input handling, while operands and results were displayed on a multiplexed <b>7-Segment Display</b>. The hierarchical design included <b>One-Bit</b> and <b>Four-Bit Arithmetic Units</b>, controlled by the FSM-based control unit. The entire system was implemented in <b>Xilinx ISE</b>, simulated using <b>test benches</b>, and deployed on an <b>FPGA board</b> with real-time visualization of operands, operations, and results.",
        "<u><b>Project Impact</b></u>",
        "This project provided deep insight into <b>CPU architecture</b> and <b>SIMD processing</b>. It reinforced hierarchical hardware design principles, control-flow implementation through FSMs, and data handling with register files. By integrating parallel arithmetic operations with synchronized control and output multiplexing, the project strengthened skills in <b>VHDL design</b>, <b>hardware verification</b>, and <b>FPGA deployment</b>, while offering practical exposure to scalable processor design concepts.",
        "<u><b>Key Skills:</b></u> VHDL | SIMD Architecture | Control Unit (FSM) | Register Files | Arithmetic Units | Hierarchical Design | Xilinx ISE | FPGA | Debouncer Circuits | 7-Segment Display Multiplexing | Test Bench Development | Hardware Simulation & Verification"
        ],
        images: ["assets/RCS_L3_1.png", "assets/RCS_L3_2.png", "assets/RCS_L3_3.png", "assets/RCS_L3_4.png", "assets/RCS_L3_5.png"],
        videos: [],
        downloads: ["downloads/RCS_L3.zip"],
        links: [{ label: "GitHub Repository", url: "https://github.com/Aamir-Ir/VHDL_Achievements/tree/main/VHDL%20-%20Intermediate/SIMD%20Strcuture%20-%20ALU%20%2B%20Control%20Unit"}],
        code: `-- VHDL SOURCE CODE FILE FOR TOP MOST MODULE (HIERARCHICAL DESIGN) SEVEN SEGMENT DECODER FOR CPU (ALU + CONTROL UNIT) (RCS_L3):
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity Top_Module is
    Port (
        clk : in STD_LOGIC;
        reset : in STD_LOGIC;
        state : in STD_LOGIC;
        SW : in STD_LOGIC_VECTOR(7 downto 0);
        LED : out STD_LOGIC_VECTOR(7 downto 0);
        AN : out STD_LOGIC_VECTOR(7 downto 0);
        Cathode : out STD_LOGIC_VECTOR(6 downto 0);
        carryLED1 : out STD_LOGIC;
        carryLED2 : out STD_LOGIC;
        SC_LED : out STD_LOGIC;
        S1_LED : out STD_LOGIC;
        S0_LED : out STD_LOGIC
    );
end Top_Module;

architecture Behavioral of Top_Module is
    signal sum : STD_LOGIC_VECTOR(5 downto 0); --changed range
    signal carry_out : STD_LOGIC;
    
    signal sum2 : STD_LOGIC_VECTOR(5 downto 0); --changed range
    signal carry_out2 : STD_LOGIC;

    signal SCin_top : STD_LOGIC;
    signal S1_top : STD_LOGIC;
    signal S0_top : STD_LOGIC;
    
    -- For Operands
    signal operand1 : STD_LOGIC_VECTOR(3 downto 0);
    signal operand2 : STD_LOGIC_VECTOR(3 downto 0);
    signal operand3 : STD_LOGIC_VECTOR(3 downto 0);
    signal operand4 : STD_LOGIC_VECTOR(3 downto 0);
    
    signal operand1SegmentDis : STD_LOGIC_VECTOR (6 downto 0);
    signal operand2SegmentDis : STD_LOGIC_VECTOR (6 downto 0);
    signal operand3SegmentDis : STD_LOGIC_VECTOR (6 downto 0);
    signal operand4SegmentDis : STD_LOGIC_VECTOR (6 downto 0);
    
    -- For Ans
    signal lowBits : STD_LOGIC_VECTOR(3 downto 0);
    signal highBits : STD_LOGIC_VECTOR(3 downto 0);
    signal lowSegmentDis : STD_LOGIC_VECTOR (6 downto 0);
--    signal highSegmentDis : STD_LOGIC_VECTOR (6 downto 0);
    signal lowBits2 : STD_LOGIC_VECTOR(3 downto 0);
    signal highBits2 : STD_LOGIC_VECTOR(3 downto 0);
    signal lowSegmentDis2 : STD_LOGIC_VECTOR (6 downto 0);
    
    signal num : integer := 0;
    signal counter : integer range 0 to 32000 := 0;
    
    signal debounce_state : STD_LOGIC;
begin
    carryLED1 <= carry_out;  -- using the first LED as carry indicator
    carryLED2 <= carry_out2;
    LED(7 downto 0) <= SW(7 downto 0);
    
    SC_LED <= SCin_top; 
    S1_LED <= S1_top; 
    S0_LED <= S0_top; 
    

    dbounce : entity work.dbounce port map (
            push_bt => state,
            clk => clk,
            debounce_out => debounce_state                        
    );
    
    reg1 : entity work.RegFile1 port map (
            ReadA => SW(3 downto 0), --SW(7 downto 4)
            DataOut => operand1,
            CLK => clk
    );
    
    reg2 : entity work.RegFile2 port map (
            ReadA => SW(7 downto 4), --SW(3 downto 0)
            DataOut => operand2,
            CLK => clk
    );
    
    reg3 : entity work.RegFile3 port map (
            ReadA => SW(3 downto 0),
            DataOut => operand3,
            CLK => clk
    );
    
    reg4 : entity work.RegFile4 port map (
            ReadA => SW(7 downto 4),
            DataOut => operand4,
            CLK => clk
    );
    
    ControlUnit : entity work.controlUnit port map (
            clk => clk,
            reset => reset,
            stateStop => debounce_state,
            SCin_CU => SCin_top,
            S0_CU => S0_top,
            S1_CU => S1_top
    );
    
    -- Instantiate the Four Bit Arithmetic Unit.
    FBAU_1 : entity work.FourBitAU port map (
        A_FBAU => operand1,   
        B_FBAU => operand2,  
        Cin_FBAU => SCin_top,
        G_FBAU => sum(3 downto 0),
        Cout_FBAU => carry_out,
        S0_FBAU => S0_top, 
        S1_FBAU => S1_top  
    );
    lowBits <= sum(3 downto 0);
    sum(4) <= carry_out; --added
    highBits <= "000" & sum(4); --changed to sum6
    
    decode_op1 : entity work.BCD_7SegDecoder port map (
            Input_7SD => operand1,
            a_to_g => operand1SegmentDis
    );
    
    decode_op2 : entity work.BCD_7SegDecoder port map (
        Input_7SD => operand2,
        a_to_g => operand2SegmentDis
    );
    
--    lowBits <= sum(3 downto 0);
--    highBits <= "000" & sum(4); --changed to sum6
    
    decode_low : entity work.BCD_7SegDecoder port map (
        Input_7SD => lowBits,
        a_to_g => lowSegmentDis
    );
        
--    decode_high : entity work.BCD_7SegDecoder port map (
--        Input_7SD => highBits,
--        a_to_g => highSegmentDis
--    );

-- Register 3 and 4 

 -- Instantiate the Four Bit Arithmetic Unit.
    FBAU_2 : entity work.FourBitAU port map (
        A_FBAU => operand3,   
        B_FBAU => operand4,  
        Cin_FBAU => SCin_top,
        G_FBAU => sum2(3 downto 0),
        Cout_FBAU => carry_out2,
        S0_FBAU => S0_top, 
        S1_FBAU => S1_top 
    );
    lowBits2 <= sum2(3 downto 0);
    sum2(4) <= carry_out2; --added
    highBits2 <= "000" & sum(4); --changed to sum6
    
    decode_op3 : entity work.BCD_7SegDecoder port map (
            Input_7SD => operand3,
            a_to_g => operand3SegmentDis
    );
    
    decode_op4 : entity work.BCD_7SegDecoder port map (
        Input_7SD => operand4,
        a_to_g => operand4SegmentDis
    );
    
--    lowBits <= sum(3 downto 0);
--    highBits <= "000" & sum(4); --changed to sum6
    
    decode_low2 : entity work.BCD_7SegDecoder port map (
        Input_7SD => lowBits2,
        a_to_g => lowSegmentDis2
    );
        
--    decode_high : entity work.BCD_7SegDecoder port map (
--        Input_7SD => highBits,
--        a_to_g => highSegmentDis
--    );



process(clk) 
begin
    if rising_edge(clk) then 
        if counter >= 5000 then -- 5 ms assuming 100 MHz clock 
            if num = 0 then 
                num <= 1; 
                AN <= "11101111"; -- rightmost digit 
                Cathode <= lowSegmentDis; 
            elsif num = 1 then -- Use "elsif" instead of "else if" 
                num <= 2; 
                AN <= "01111111"; -- Operand 1 from reg 1 
                Cathode <= operand1SegmentDis; 
            elsif num = 2 then
                num <= 3; 
                AN <= "10111111"; -- Operand 2 From reg 2 
                Cathode <= operand2SegmentDis; 
            elsif num = 3 then
                num <= 4; 
                AN <= "11111110"; -- Operand 2 From reg 2 
                Cathode <= lowSegmentDis2;
            elsif num = 4 then
                num <= 5; 
                AN <= "11110111"; -- Operand 2 From reg 2 
                Cathode <= operand3SegmentDis;
            else
                num <= 0; 
                AN <= "11111011"; -- Operand 2 From reg 2 
                Cathode <= operand4SegmentDis; 
            end if; 
            counter <= 0; 
        else 
            counter <= counter + 1; 
        end if; 
    end if; 

end process; 
        

end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR DeBounce Circuit:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity dbounce is
    Port ( push_bt : in STD_LOGIC;
           clk : in STD_LOGIC;
           debounce_out : out STD_LOGIC);
end dbounce;

architecture Behavioral of dbounce is
signal d1, d2, reset, cout : std_logic;
signal count : std_logic_vector(20 downto 0);
begin

reset <= d1 xor d2;

FF: process(clk)
begin
    if (clk'event and clk = '1') then
        d1 <= push_bt;
        d2 <= d1;
        if (cout = '1') then
            debounce_out <= d2;
        end if;
    end if;
end process;

CNTR: process(clk, reset)
begin
    if (reset='1') then
        count <= (others => '0');
    elsif (clk'event and clk = '1') then
        if (cout = '0') then
            count <= count + 1;
        end if;
    end if;
end process;

cout <= count(20);

end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR RegFile1:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity RegFile1 is
    generic (
        Dwidth : integer := 4;
        Awidth : integer := 4
    );
    
    Port ( 
        ReadA : IN std_logic_vector(Awidth-1 downto 0);
        DataOut : OUT std_logic_vector(Dwidth-1 downto 0);
        CLK : in std_logic
    );
end RegFile1;

architecture Behavioral of RegFile1 is
type memType is array(0 to 2**Awidth-1) of std_logic_vector(Dwidth-1 downto 0);

-- The first 8 locations are initialized, the rest set to 0.

signal memory: memType := (
    "0000",
    "0001",
    "0010",
    "0011",
    "0100",
    "0101",
    "0110",
    "0111",
    "1000",
    "1001",
    "1010",
    "1011",
    "1100",
    others => "1111");
begin
    process(CLK)
    begin
    
    if (clk'event and clk = '1') then
        DataOut <= memory(conv_integer(ReadA));
    end if;
    
    end process;
end Behavioral;


----------------------------------------------------------------------------------
-- VHDL CODE FOR RegFile2:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity RegFile2 is
    generic (
        Dwidth : integer := 4;
        Awidth : integer := 4
    );
    
    Port ( 
        ReadA : IN std_logic_vector(Awidth-1 downto 0);
        DataOut : OUT std_logic_vector(Dwidth-1 downto 0);
        CLK : in std_logic
    );
end RegFile2;

architecture Behavioral of RegFile2 is
type memType is array(0 to 2**Awidth-1) of std_logic_vector(Dwidth-1 downto 0);

-- The first 8 locations are initialized, the rest set to 0.

signal memory: memType := (
    "1100",  -- "0000"
    "1011",  -- "0001"
    "1010",  -- "0010"
    "1001",  -- "0011"
    "1000",  -- "0100"
    "0111",  -- "0101"
    "1101",  -- "0110"
    "0101",  -- "0111"
    "0100",  -- "1000"
    "0011",  -- "1001"
    "0010",  -- "1010"
    "0001",  -- "1011"
    "0000",  -- "1100"
    others => "0000");
begin
    process(CLK)
    begin
    
    if (clk'event and clk = '1') then
        DataOut <= memory(conv_integer(ReadA));
    end if;
    
    end process;
end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR RegFile3:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity RegFile3 is
    generic (
        Dwidth : integer := 4;
        Awidth : integer := 4
    );
    
    Port ( 
        ReadA : IN std_logic_vector(Awidth-1 downto 0);
        DataOut : OUT std_logic_vector(Dwidth-1 downto 0);
        CLK : in std_logic
    );
end RegFile3;

architecture Behavioral of RegFile3 is
type memType is array(0 to 2**Awidth-1) of std_logic_vector(Dwidth-1 downto 0);

-- The first 8 locations are initialized, the rest set to 0.

signal memory: memType := (
    "1001",  -- "0000"
    "0110",  -- "0001"
    "0101",  -- "0010"
    "1010",  -- "0011"
    "1000",  -- "0100"
    "0111",  -- "0101"
    "1111",  -- "0110"
    "1111",  -- "0111"
    "0111",  -- "1000"
    "1010",  -- "1001"
    "0101",  -- "1010"
    "0110",  -- "1011"
    "1001",  -- "1100"
    others => "0110");
begin
    process(CLK)
    begin
    
    if (clk'event and clk = '1') then
        DataOut <= memory(conv_integer(ReadA));
    end if;
    
    end process;
end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR RegFile4:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity RegFile4 is
    generic (
        Dwidth : integer := 4;
        Awidth : integer := 4
    );
    
    Port ( 
        ReadA : IN std_logic_vector(Awidth-1 downto 0);
        DataOut : OUT std_logic_vector(Dwidth-1 downto 0);
        CLK : in std_logic
    );
end RegFile4;

architecture Behavioral of RegFile4 is
type memType is array(0 to 2**Awidth-1) of std_logic_vector(Dwidth-1 downto 0);

-- The first 8 locations are initialized, the rest set to 0.

signal memory: memType := (
    "0000",  -- "0000"
    "0100",  -- "0001"
    "1101",  -- "0010"
    "1111",  -- "0011"
    "1000",  -- "0100"
    "0111",  -- "0101"
    "1111",  -- "0110"
    "1110",  -- "0111"
    "0111",  -- "1000"
    "0101",  -- "1001"
    "1010",  -- "1010"
    "0110",  -- "1011"
    "1111",  -- "1100"
    others => "1001");
begin
    process(CLK)
    begin
    
    if (clk'event and clk = '1') then
        DataOut <= memory(conv_integer(ReadA));
    end if;
    
    end process;


end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR Control Unit:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity controlUnit is
  Port ( clk : IN STD_LOGIC;
         reset : IN STD_LOGIC;
         stateStop : IN STD_LOGIC;
         SCin_CU : OUT STD_LOGIC;
         S0_CU : OUT STD_LOGIC;
         S1_CU : OUT STD_LOGIC);
end controlUnit;

architecture Behavioral of controlUnit is
    type statetype is (idle_state, A_plus_B, AComp_plus_B, A_minus_1, Acomp, A_minus_B, B_minus_A, A_plus_1, Acomp_plus_1);
    signal present_state, next_state: statetype;
Begin
clk_process: process(reset, clk)
begin
    if reset = '1' then -- Check for reset and initialize state.
        present_state <= idle_state;
    Elsif (rising_edge(clk)) then
        present_state <= next_state;
    end if;
end process clk_process;
                
next_state_process: process(present_state) is
begin
    case present_state is --depending on the current state. Just move to the next operation in line.
    when idle_state => -- set next state.
        if stateStop = '1' then
            next_state <= A_plus_B;
        else
            next_state <= idle_state;
        end if;     
    when A_plus_B => -- set next state.
        if stateStop = '1' then
            next_state <= AComp_plus_B;
        else
            next_state <= A_plus_B;
        end if;
    when AComp_plus_B =>
        if stateStop = '1' then
            next_state <= A_minus_1;
        else
            next_state <= AComp_plus_B;
        end if;
    when A_minus_1 =>
        if stateStop = '1' then
            next_state <= Acomp;
        else
            next_state <= A_minus_1;
        end if;
    when Acomp =>
        if stateStop = '1' then
            next_state <= A_minus_B;
        else
            next_state <= Acomp;
        end if;
    when A_minus_B =>
        if stateStop = '1' then
            next_state <= B_minus_A;
        else
            next_state <= A_minus_B;
        end if;
    when B_minus_A =>
        if stateStop = '1' then
            next_state <= A_plus_1;
        else
            next_state <= B_minus_A;
        end if;
    when A_plus_1 =>
        if stateStop = '1' then
            next_state <= Acomp_plus_1;
        else
            next_state <= A_plus_1;
        end if;
    when Acomp_plus_1 =>
        if stateStop = '1' then
            next_state <= A_plus_B;
        else
            next_state <= Acomp_plus_1;
        end if;
    end case;
end process next_state_process;   

output_process: process(present_state) is
begin
    case present_state is -- depending on the current state set select signals
    when idle_state =>

    when A_plus_B => -- select signals for F = A + B (add).
        SCin_CU <= '0';
        S0_CU <= '0';
        S1_CU <= '0';
    when AComp_plus_B => -- select signals for F = A' + B.
        SCin_CU <= '0';
        S0_CU <= '1';
        S1_CU <= '0';
    when A_minus_1 =>  -- select signals for F = A - 1.
        SCin_CU <= '0';
        S0_CU <= '0';
        S1_CU <= '1';
    when Acomp =>  -- select signals for F = A'.
        SCin_CU <= '0';
        S0_CU <= '1';
        S1_CU <= '1';
    when A_minus_B =>  -- select signals for F = A - B.
        SCin_CU <= '1';
        S0_CU <= '0';
        S1_CU <= '0';
    when B_minus_A =>   -- select signals for F = B - A.
        SCin_CU <= '1';
        S0_CU <= '1';
        S1_CU <= '0';
    when A_plus_1 =>     -- select signals for F = A + 1.
        SCin_CU <= '1';
        S0_CU <= '0';
        S1_CU <= '1';
    when Acomp_plus_1 =>    -- select signals for F = A' + 1.
        SCin_CU <= '1';
        S0_CU <= '1';
        S1_CU <= '1';
    end case;
end process output_process;

end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR Four Bit Arithmetic Unit (FBAU):
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity FourBitAU is

    generic (N_BITS : integer := 4);
    
    Port ( A_FBAU : in STD_LOGIC_VECTOR (N_BITS-1 downto 0);
           B_FBAU : in STD_LOGIC_VECTOR (N_BITS-1 downto 0);
           Cin_FBAU : in STD_LOGIC;
           G_FBAU : out STD_LOGIC_VECTOR (N_BITS-1 downto 0);
           Cout_FBAU : out STD_LOGIC;
           S0_FBAU : in STD_LOGIC;
           S1_FBAU : in STD_LOGIC);
end FourBitAU;

architecture Behavioral of FourBitAU is

component OneBitAU is
    Port ( Ain_AU : in STD_LOGIC;
           Bin_AU : in STD_LOGIC;
           Cin_AU : in STD_LOGIC;
           SCin_AU : in STD_LOGIC;
           S1_AU : in STD_LOGIC;
           S0_AU : in STD_LOGIC;
           G_AU : out STD_LOGIC;
           Cout_AU : out STD_LOGIC);
end component;

signal SCin_FBAU : STD_LOGIC;
signal Carry : STD_LOGIC_VECTOR(N_BITS downto 0) := (others => '0'); --Set

begin
    SCin_FBAU <= Cin_FBAU;
    Carry(0) <= Cin_FBAU;
    make_each_AU: for i in 0 to N_BITS-1 generate            -- Loop through each 1 bit AU and port everything.
        signal CarryOut_i : STD_LOGIC;                       -- This will catch each output of every carry out for each 1 bit AU.
    begin
        OneBitAU_inst : OneBitAU                           -- hierarchy for One Bit AU + port (Make sure to look at the circuit and understand each ports.)
            port map (
                Ain_AU => A_FBAU(i),                          -- A(N) passed. Done For all 4 bits of operand 1
                Bin_AU => B_FBAU(i),                          -- B(N) passed. Done For all 4 bits of operand 2
                Cin_AU => Carry(i),                         -- Previous Carry in passed in from the update or Cin_FBAU initally.
                SCin_AU => SCin_FBAU,
                S0_AU => S0_FBAU,                      	    -- Selects never iterate for the One bit AU's.
                S1_AU => S1_FBAU,
                G_AU => G_FBAU(i), 			    -- G_AU(N) recives output of AU
                Cout_AU => CarryOut_i                  -- CarryOut_i updated and used a temp for carry vector.
            );
            Carry(i+1) <= CarryOut_i;         
     end generate make_each_AU;
     
     Cout_FBAU <= Carry(4);

end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR SEVEN SEGMENT DECODER:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity BCD_7SegDecoder is
    Port ( Input_7SD : in STD_LOGIC_VECTOR (3 downto 0);
           a_to_g : out STD_LOGIC_VECTOR (6 downto 0));
end BCD_7SegDecoder;

architecture Behavioral of BCD_7SegDecoder is

begin
   process(Input_7SD)
   begin   
     case Input_7SD is                                  -- a,b,c,d,e,f,g
         when "0000" => a_to_g <= "1000000"; --0
         when "0001" => a_to_g <= "1111001"; --1        1001111         1111001
         when "0010" => a_to_g <= "0100100"; --2     0010010  0100100
         when "0011" => a_to_g <= "0110000"; --3         
         when "0100" => a_to_g <= "0011001"; --4         
         when "0101" => a_to_g <= "0010010"; --5             
         when "0110" => a_to_g <= "0000010"; --6 
         when "0111" => a_to_g <= "1011000"; --7
         when "1000" => a_to_g <= "0000000"; --8
         when "1001" => a_to_g <= "0010000"; --9         
         when "1010" => a_to_g <= "0001000"; --A
         when "1011" => a_to_g <= "0000011"; --b         
         when "1100" => a_to_g <= "1000110"; --C         z
         when "1101" => a_to_g <= "0100001"; --d    
         when "1110" => a_to_g <= "0000110"; --E    
         when "1111" => a_to_g <= "0001110"; --F    
     end case;
   end process;
end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR ONE Bit Arithmetic Unit:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity OneBitAU is
    Port ( Ain_AU : in STD_LOGIC;
           Bin_AU : in STD_LOGIC;
           Cin_AU : in STD_LOGIC;
           SCin_AU : in STD_LOGIC;
           S1_AU : in STD_LOGIC;
           S0_AU : in STD_LOGIC;
           G_AU : out STD_LOGIC;
           Cout_AU : out STD_LOGIC);
end OneBitAU;

architecture Behavioral of OneBitAU is

    component ArithmeticInputLogicA is
        Port ( S0_AILA : in STD_LOGIC;
               Ain_AILA : in STD_LOGIC;
               Aout_AILA : out STD_LOGIC);
    end component;
    
    component ArithmeticInputLogicB is
        Port ( SCin_AILB : in STD_LOGIC;
               S1_AILB : in STD_LOGIC;
               S0_AILB : in STD_LOGIC;
               Bin_AILB : in STD_LOGIC;
               Bout_AILB : out STD_LOGIC);
    end component;


    component FullAdder is
    Port ( A_Full : in STD_LOGIC;
           B_Full : in STD_LOGIC;
           CarryIn_Full : in STD_LOGIC;
           Sum_Full : out STD_LOGIC;
           CarryOut_Full : out STD_LOGIC);
    end component;

    SIGNAL Apostlogic:STD_LOGIC;
    SIGNAL Bpostlogic:STD_LOGIC;
	
begin
    -- All Logic required for OneBitAU according to my diagram Sir Aamir Irfan's diagram ( I AM HIM )
ALogic:ArithmeticInputLogicA PORT MAP(S0_AILA=>S0_AU, Ain_AILA=>Ain_AU, Aout_AILA=>Apostlogic);
BLogic:ArithmeticInputLogicB PORT MAP(SCin_AILB=>SCin_AU, S1_AILB=>S1_AU, S0_AILB=>S0_AU, Bin_AILB=>Bin_AU, Bout_AILB=>Bpostlogic);
FA1:FullAdder PORT MAP(A_Full => Apostlogic, B_Full => Bpostlogic, CarryIn_Full => Cin_AU, Sum_Full => G_AU,CarryOut_Full => Cout_AU);


end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR ArithmeticInputLogicA:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity ArithmeticInputLogicA is
    Port ( S0_AILA : in STD_LOGIC;
           Ain_AILA : in STD_LOGIC;
           Aout_AILA : out STD_LOGIC);
end ArithmeticInputLogicA;

architecture Behavioral of ArithmeticInputLogicA is

begin

    -- Logic required to handle A depending on select lines. No need for Cin_AILA and S1in_AILA as if you do K-map it is irrelavant. 
    
    Aout_AILA <= Ain_AILA when (S0_AILA = '0')
        else (not Ain_AILA) when (S0_AILA = '1');

end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR ArithmeticInputLogicB:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity ArithmeticInputLogicB is
    Port ( SCin_AILB : in STD_LOGIC;
           S1_AILB : in STD_LOGIC;
           S0_AILB : in STD_LOGIC;
           Bin_AILB : in STD_LOGIC;
           Bout_AILB : out STD_LOGIC);
end ArithmeticInputLogicB;

architecture Behavioral of ArithmeticInputLogicB is

begin

     -- Logic required to handle B_AU depending on select lines. Here we simply look at look up table given in lab. Can't optimize to many distincct cases.
     
    Bout_AILB <= Bin_AILB when (SCin_AILB = '0' and S1_AILB = '0' and S0_AILB = '0')
        else Bin_AILB when (SCin_AILB = '0' and S1_AILB = '0' and S0_AILB = '1')
        else '1' when (SCin_AILB = '0' and S1_AILB = '1' and S0_AILB = '0')
        else '0' when (SCin_AILB = '0' and S1_AILB = '1' and S0_AILB = '1')
        else (not Bin_AILB) when (SCin_AILB = '1' and S1_AILB = '0' and S0_AILB = '0')
        else Bin_AILB when (SCin_AILB = '1' and S1_AILB = '0' and S0_AILB = '1')
        else '0' when (SCin_AILB = '1' and S1_AILB = '1' and S0_AILB = '0')
        else '0' when (SCin_AILB = '1' and S1_AILB = '1' and S0_AILB = '1');

end Behavioral;

----------------------------------------------------------------------------------
--VHDL CODE FOR FULL ADDER:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity FullAdder is
    Port ( A_Full : in STD_LOGIC;
           B_Full : in STD_LOGIC;
           CarryIn_Full : in STD_LOGIC;
           Sum_Full : out STD_LOGIC;
           CarryOut_Full : out STD_LOGIC);
end FullAdder;

architecture Behavioral of FullAdder is
    
    -- Component and Output signals needed for between operations.
    
    component HalfAdder is
        Port ( A_Half : in STD_LOGIC;
               B_Half : in STD_LOGIC;
               Sum_Half : out STD_LOGIC;
               CarryOut_Half : out STD_LOGIC);
    end component HalfAdder;
    
    signal sum_half_tmp : STD_LOGIC;
    signal CarryOut_half0 : STD_LOGIC;
    signal CarryOut_half1 : STD_LOGIC;
    
begin

    -- Logic for a FullAdder.
    
    ha1: HalfAdder
        port map(A_Half => A_Full, B_Half => B_Full, Sum_Half => sum_half_tmp, CarryOut_Half => CarryOut_half0);

    ha2: HalfAdder
        port map(A_Half => sum_half_tmp, B_Half => CarryIn_Full, Sum_Half => Sum_Full, CarryOut_Half => CarryOut_half1);
        
    CarryOut_Full <= CarryOut_half1 OR CarryOut_half0;

end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR HALF ADDER:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity HalfAdder is
    Port ( A_Half : in STD_LOGIC;
           B_Half : in STD_LOGIC;
           Sum_Half : out STD_LOGIC;
           CarryOut_Half : out STD_LOGIC);
end HalfAdder;

architecture Behavioral of HalfAdder is

begin
    -- Logic inside a Half Adder.
    
    CarryOut_Half <= A_Half AND B_Half;
    Sum_Half <= A_Half XOR B_Half;

end Behavioral;

----------------------------------------------------------------------------------
-- VHDL TEST BENCH CODE FOR TOP MODULE:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity Top_Module_TB is
--  Port ( );
end Top_Module_TB;

architecture Behavioral of Top_Module_TB is
  -- Declare signals for your testbench inputs and outputs
  signal clk : STD_LOGIC := '0';
  signal reset : STD_LOGIC := '0';
  signal state : STD_LOGIC := '0';
  signal SW : STD_LOGIC_VECTOR(7 downto 0) := (others => '0');
  signal LED : STD_LOGIC_VECTOR(7 downto 0);
  signal AN : STD_LOGIC_VECTOR(7 downto 0);
  signal Cathode : STD_LOGIC_VECTOR(6 downto 0);
  signal carryLED1 : STD_LOGIC;
  signal carryLED2 : STD_LOGIC;
  signal SC_LED : STD_LOGIC;
  signal S1_LED : STD_LOGIC;
  signal S0_LED : STD_LOGIC;

  -- Instantiate your Top_Module component
  component Top_Module is
    Port (
        clk : in STD_LOGIC;
        reset : in STD_LOGIC;
        state : in STD_LOGIC;
        SW : in STD_LOGIC_VECTOR(7 downto 0);
        LED : out STD_LOGIC_VECTOR(7 downto 0);
        AN : out STD_LOGIC_VECTOR(7 downto 0);
        Cathode : out STD_LOGIC_VECTOR(6 downto 0);
        carryLED1 : out STD_LOGIC;
        carryLED2 : out STD_LOGIC;
        SC_LED : out STD_LOGIC;
        S1_LED : out STD_LOGIC;
        S0_LED : out STD_LOGIC
    );
  end component;

begin
  -- Instantiate your Top_Module component
  uut: Top_Module port map (
    clk => clk,
    reset => reset,
    state => state,
    SW => SW,
    LED => LED,
    AN => AN,
    Cathode => Cathode,
    carryLED1 => carryLED1,
    carryLED2 => carryLED2,
    SC_LED => SC_LED,
    S1_LED => S1_LED,
    S0_LED => S0_LED
  );

  -- Clock generation process
  clk_process: process
  begin
    while now < 1000 ns loop  -- Adjust the simulation time as needed
      clk <= not clk;  -- Toggle the clock signal
      wait for 5 ns;  -- Adjust the clock period as needed
    end loop;
    wait;
  end process;

  -- Stimulus process
  stimulus_process: process
  begin
    -- Apply test vectors and reset as needed here
    -- For example:
    reset <= '0';
    state <= '0';
    SW <= "00000000";

    wait for 10 ns;

    -- Continue with more test vectors as needed

    wait;
  end process;

end Behavioral;

`
      },
      {
        id: "ALU_7Segs",
        name: "ALU",
        summary: [
          "<u><b>Building Process</b></u>",
          "This project involved designing a hierarchical <b>4-bit Arithmetic Unit (AU)</b> in <b>VHDL</b>, built from <b>Half Adders</b>, <b>Full Adders</b>, and <b>Arithmetic Input Logic modules</b> to form <b>One-Bit</b> and <b>Four-Bit AUs</b>. The AU supported multiple arithmetic and logic operations controlled by selection inputs. Results, along with operands, were displayed on a multiplexed <b>7-Segment Display Decoder</b> for real-time visualization. A <b>top-level module</b> integrated switches, LEDs, carry indicators, and display control logic. The design was implemented in <b>Xilinx ISE</b>, thoroughly verified using <b>test benches</b>, and simulated before being deployed on an <b>FPGA board</b>.",
          "<u><b>Project Impact</b></u>",
          "This project reinforced understanding of <b>ALU architecture</b> and <b>hierarchical modular design</b> in VHDL. It provided hands-on experience in implementing arithmetic/logic selection control, real-time <b>7-segment multiplexing</b>, and structured hardware verification. The work strengthened skills in <b>debugging</b>, <b>simulation</b>, and <b>hardware deployment</b>, essential for scalable and efficient digital system design.",
          "<u><b>Key Skills:</b></u> VHDL | ALU & Arithmetic Circuits | Hierarchical Design | Xilinx ISE | FPGA | Half & Full Adders | Arithmetic Input Logic Modules | 7-Segment Display Multiplexing | Modular Architecture | Test Bench Development | Hardware Simulation & Verification"
        ],
        images: ["assets/RCS_L2_1.png", "assets/RCS_L2_2.png", "assets/RCS_L2_3.png", "assets/RCS_L2_4.png", "assets/RCS_L2_5.png", "assets/RCS_L2_6.png", "assets/RCS_L2_7.png", "assets/RCS_L2_8.png", "assets/RCS_L2_9.png"],
        videos: [],
        downloads: ["downloads/RCS_L2.zip"],
        links: [{ label: "GitHub Repository", url: "https://github.com/Aamir-Ir/VHDL_Achievements/tree/main/VHDL%20-%20Intermediate/4%20Bit%20ALU"}],
        code: `-- VHDL SOURCE CODE FILE FOR TOP MOST MODULE (HIERARCHICAL DESIGN) SEVEN SEGMENT DECODER FOR ALU (RCS_L2):
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity Top_Module is
    Port (
        clk : in STD_LOGIC;
        SW : in STD_LOGIC_VECTOR(10 downto 0);
        LED : out STD_LOGIC_VECTOR(10 downto 0);
        AN : out STD_LOGIC_VECTOR(7 downto 0);
        Cathode : out STD_LOGIC_VECTOR(6 downto 0);
        carryLED : out STD_LOGIC
    );
end Top_Module;

architecture Behavioral of Top_Module is
    signal sum : STD_LOGIC_VECTOR(5 downto 0); --changed range
    signal carry_out : STD_LOGIC;

    -- For Operands
--    signal operand1 : STD_LOGIC_VECTOR(3 downto 0);
--    signal operand2 : STD_LOGIC_VECTOR(3 downto 0);
    
    signal operand1SegmentDis : STD_LOGIC_VECTOR (6 downto 0);
    signal operand2SegmentDis : STD_LOGIC_VECTOR (6 downto 0);
    
    -- For Ans
    signal lowBits : STD_LOGIC_VECTOR(3 downto 0);
    signal highBits : STD_LOGIC_VECTOR(3 downto 0);
    signal lowSegmentDis : STD_LOGIC_VECTOR (6 downto 0);
--    signal highSegmentDis : STD_LOGIC_VECTOR (6 downto 0);
    
    signal num : integer := 0;
    signal counter : integer range 0 to 32000 := 0;
begin
    carryLED <= carry_out;  -- using the first LED as carry indicator
    LED(10 downto 0) <= SW(10 downto 0);

    -- Instantiate the ripple carry adder
    Adder : entity work.FourBitAU port map (
        A_FBAU => SW(10 downto 7),   --SW(6 downto 3)
        B_FBAU => SW(6 downto 3),  --SW(10 downto 7)
        Cin_FBAU => SW(2),
        G_FBAU => sum(3 downto 0),
        Cout_FBAU => carry_out,
        S0_FBAU => SW(0), --SW(1)
        S1_FBAU => SW(1)  --SW(0)
    );
    lowBits <= sum(3 downto 0);
    sum(4) <= carry_out; --added
    highBits <= "000" & sum(4); --changed to sum6
    
    decode_op1 : entity work.BCD_7SegDecoder port map (
            Input_7SD => SW(6 downto 3),
            a_to_g => operand1SegmentDis
    );
    
    decode_op2 : entity work.BCD_7SegDecoder port map (
        Input_7SD => SW(10 downto 7),
        a_to_g => operand2SegmentDis
    );
    
--    lowBits <= sum(3 downto 0);
--    highBits <= "000" & sum(4); --changed to sum6
    
    decode_low : entity work.BCD_7SegDecoder port map (
        Input_7SD => lowBits,
        a_to_g => lowSegmentDis
    );
        
--    decode_high : entity work.BCD_7SegDecoder port map (
--        Input_7SD => highBits,
--        a_to_g => highSegmentDis
--    );

process(clk) 
begin
    if rising_edge(clk) then 
        if counter >= 5000 then -- 5 ms assuming 100 MHz clock 
            if num = 0 then 
                num <= 1; 
                AN <= "11111110"; -- rightmost digit 
                Cathode <= lowSegmentDis; 
--            elsif num = 1 then -- Use "elsif" instead of "else if" 
--                num <= 2; 
--                AN <= "11111101"; -- second rightmost digit 
--                Cathode <= highSegmentDis; 
            elsif num = 1 then -- Use "elsif" instead of "else if" 
                num <= 2; 
                AN <= "11101111"; -- second rightmost digit 
                Cathode <= operand1SegmentDis; 
            else 
                num <= 0; 
                AN <= "10111111"; -- second rightmost digit 
                Cathode <= operand2SegmentDis; 
            end if; 
            counter <= 0; 
        else 
            counter <= counter + 1; 
        end if; 
    end if; 

end process; 
        

end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR 7-SEGMENT DECODER:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity BCD_7SegDecoder is
    Port ( Input_7SD : in STD_LOGIC_VECTOR (3 downto 0);
           a_to_g : out STD_LOGIC_VECTOR (6 downto 0));
end BCD_7SegDecoder;

architecture Behavioral of BCD_7SegDecoder is

begin
   process(Input_7SD)
   begin   
     case Input_7SD is                                  -- a,b,c,d,e,f,g
         when "0000" => a_to_g <= "1000000"; --0
         when "0001" => a_to_g <= "1111001"; --1        1001111         1111001
         when "0010" => a_to_g <= "0100100"; --2     0010010  0100100
         when "0011" => a_to_g <= "0110000"; --3         
         when "0100" => a_to_g <= "0011001"; --4         
         when "0101" => a_to_g <= "0010010"; --5             
         when "0110" => a_to_g <= "0000010"; --6 
         when "0111" => a_to_g <= "1011000"; --7
         when "1000" => a_to_g <= "0000000"; --8
         when "1001" => a_to_g <= "0010000"; --9         
         when "1010" => a_to_g <= "0001000"; --A
         when "1011" => a_to_g <= "0000011"; --b         
         when "1100" => a_to_g <= "1000110"; --C         z
         when "1101" => a_to_g <= "0100001"; --d    
         when "1110" => a_to_g <= "0000110"; --E    
         when "1111" => a_to_g <= "0001110"; --F    
     end case;
   end process;
end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR FOUR BIT AU:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity FourBitAU is

    generic (N_BITS : integer := 4);
    
    Port ( A_FBAU : in STD_LOGIC_VECTOR (N_BITS-1 downto 0);
           B_FBAU : in STD_LOGIC_VECTOR (N_BITS-1 downto 0);
           Cin_FBAU : in STD_LOGIC;
           G_FBAU : out STD_LOGIC_VECTOR (N_BITS-1 downto 0);
           Cout_FBAU : out STD_LOGIC;
           S0_FBAU : in STD_LOGIC;
           S1_FBAU : in STD_LOGIC);
end FourBitAU;

architecture Behavioral of FourBitAU is

component OneBitAU is
    Port ( Ain_AU : in STD_LOGIC;
           Bin_AU : in STD_LOGIC;
           Cin_AU : in STD_LOGIC;
           SCin_AU : in STD_LOGIC;
           S1_AU : in STD_LOGIC;
           S0_AU : in STD_LOGIC;
           G_AU : out STD_LOGIC;
           Cout_AU : out STD_LOGIC);
end component;

signal SCin_FBAU : STD_LOGIC;
signal Carry : STD_LOGIC_VECTOR(N_BITS downto 0) := (others => '0'); --Set

begin
    SCin_FBAU <= Cin_FBAU;
    Carry(0) <= Cin_FBAU;
    make_each_AU: for i in 0 to N_BITS-1 generate            -- Loop through each 1 bit AU and port everything.
        signal CarryOut_i : STD_LOGIC;                       -- This will catch each output of every carry out for each 1 bit AU.
    begin
        OneBitAU_inst : OneBitAU                           -- hierarchy for One Bit AU + port (Make sure to look at the circuit and understand each ports.)
            port map (
                Ain_AU => A_FBAU(i),                          -- A(N) passed. Done For all 4 bits of operand 1
                Bin_AU => B_FBAU(i),                          -- B(N) passed. Done For all 4 bits of operand 2
                Cin_AU => Carry(i),                         -- Previous Carry in passed in from the update or Cin_FBAU initally.
                SCin_AU => SCin_FBAU,
                S0_AU => S0_FBAU,                      	    -- Selects never iterate for the One bit AU's.
                S1_AU => S1_FBAU,
                G_AU => G_FBAU(i), 			    -- G_AU(N) recives output of AU
                Cout_AU => CarryOut_i                  -- CarryOut_i updated and used a temp for carry vector.
            );
            Carry(i+1) <= CarryOut_i;         -- Setting the updated CarryOut_i as input for the next Full Adder.
     end generate make_each_AU;
     
     Cout_FBAU <= Carry(4);

end Behavioral;

----------------------------------------------------------------------------------
--VHDL CODE FOR ONE BIT AU:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity OneBitAU is
    Port ( Ain_AU : in STD_LOGIC;
           Bin_AU : in STD_LOGIC;
           Cin_AU : in STD_LOGIC;
           SCin_AU : in STD_LOGIC;
           S1_AU : in STD_LOGIC;
           S0_AU : in STD_LOGIC;
           G_AU : out STD_LOGIC;
           Cout_AU : out STD_LOGIC);
end OneBitAU;

architecture Behavioral of OneBitAU is

    component ArithmeticInputLogicA is
        Port ( S0_AILA : in STD_LOGIC;
               Ain_AILA : in STD_LOGIC;
               Aout_AILA : out STD_LOGIC);
    end component;
    
    component ArithmeticInputLogicB is
        Port ( SCin_AILB : in STD_LOGIC;
               S1_AILB : in STD_LOGIC;
               S0_AILB : in STD_LOGIC;
               Bin_AILB : in STD_LOGIC;
               Bout_AILB : out STD_LOGIC);
    end component;


    component FullAdder is
    Port ( A_Full : in STD_LOGIC;
           B_Full : in STD_LOGIC;
           CarryIn_Full : in STD_LOGIC;
           Sum_Full : out STD_LOGIC;
           CarryOut_Full : out STD_LOGIC);
    end component;

    SIGNAL Apostlogic:STD_LOGIC;
    SIGNAL Bpostlogic:STD_LOGIC;
	
begin
    -- All Logic required for OneBitAU according to my diagram Sir Aamir Irfan's diagram ( I AM HIM )
ALogic:ArithmeticInputLogicA PORT MAP(S0_AILA=>S0_AU, Ain_AILA=>Ain_AU, Aout_AILA=>Apostlogic);
BLogic:ArithmeticInputLogicB PORT MAP(SCin_AILB=>SCin_AU, S1_AILB=>S1_AU, S0_AILB=>S0_AU, Bin_AILB=>Bin_AU, Bout_AILB=>Bpostlogic);
FA1:FullAdder PORT MAP(A_Full => Apostlogic, B_Full => Bpostlogic, CarryIn_Full => Cin_AU, Sum_Full => G_AU,CarryOut_Full => Cout_AU);


end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR ARITHMETIC_LOGIC_A:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity ArithmeticInputLogicA is
    Port ( S0_AILA : in STD_LOGIC;
           Ain_AILA : in STD_LOGIC;
           Aout_AILA : out STD_LOGIC);
end ArithmeticInputLogicA;

architecture Behavioral of ArithmeticInputLogicA is

begin

    -- Logic required to handle A depending on select lines. No need for Cin_AILA and S1in_AILA as if you do K-map it is irrelavant. 
    
    Aout_AILA <= Ain_AILA when (S0_AILA = '0')
        else (not Ain_AILA) when (S0_AILA = '1');

end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR ARITHMETIC_LOGIC_B:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity ArithmeticInputLogicB is
    Port ( SCin_AILB : in STD_LOGIC;
           S1_AILB : in STD_LOGIC;
           S0_AILB : in STD_LOGIC;
           Bin_AILB : in STD_LOGIC;
           Bout_AILB : out STD_LOGIC);
end ArithmeticInputLogicB;

architecture Behavioral of ArithmeticInputLogicB is

begin

     -- Logic required to handle B_AU depending on select lines. Here we simply look at look up table given in lab. Can't optimize to many distincct cases.
     
    Bout_AILB <= Bin_AILB when (SCin_AILB = '0' and S1_AILB = '0' and S0_AILB = '0')
        else Bin_AILB when (SCin_AILB = '0' and S1_AILB = '0' and S0_AILB = '1')
        else '1' when (SCin_AILB = '0' and S1_AILB = '1' and S0_AILB = '0')
        else '0' when (SCin_AILB = '0' and S1_AILB = '1' and S0_AILB = '1')
        else (not Bin_AILB) when (SCin_AILB = '1' and S1_AILB = '0' and S0_AILB = '0')
        else Bin_AILB when (SCin_AILB = '1' and S1_AILB = '0' and S0_AILB = '1')
        else '0' when (SCin_AILB = '1' and S1_AILB = '1' and S0_AILB = '0')
        else '0' when (SCin_AILB = '1' and S1_AILB = '1' and S0_AILB = '1');

end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR FULL ADDER:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity FullAdder is
    Port ( A_Full : in STD_LOGIC;
           B_Full : in STD_LOGIC;
           CarryIn_Full : in STD_LOGIC;
           Sum_Full : out STD_LOGIC;
           CarryOut_Full : out STD_LOGIC);
end FullAdder;

architecture Behavioral of FullAdder is
    
    -- Component and Output signals needed for between operations.
    
    component HalfAdder is
        Port ( A_Half : in STD_LOGIC;
               B_Half : in STD_LOGIC;
               Sum_Half : out STD_LOGIC;
               CarryOut_Half : out STD_LOGIC);
    end component HalfAdder;
    
    signal sum_half_tmp : STD_LOGIC;
    signal CarryOut_half0 : STD_LOGIC;
    signal CarryOut_half1 : STD_LOGIC;
    
begin

    -- Logic for a FullAdder.
    
    ha1: HalfAdder
        port map(A_Half => A_Full, B_Half => B_Full, Sum_Half => sum_half_tmp, CarryOut_Half => CarryOut_half0);

    ha2: HalfAdder
        port map(A_Half => sum_half_tmp, B_Half => CarryIn_Full, Sum_Half => Sum_Full, CarryOut_Half => CarryOut_half1);
        
    CarryOut_Full <= CarryOut_half1 OR CarryOut_half0;

end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR HALF ADDER:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity HalfAdder is
    Port ( A_Half : in STD_LOGIC;
           B_Half : in STD_LOGIC;
           Sum_Half : out STD_LOGIC;
           CarryOut_Half : out STD_LOGIC);
end HalfAdder;

architecture Behavioral of HalfAdder is

begin
    -- Logic inside a Half Adder.
    
    CarryOut_Half <= A_Half AND B_Half;
    Sum_Half <= A_Half XOR B_Half;

end Behavioral;

----------------------------------------------------------------------------------
-- VHDL TEST BENCH CODE FOR FOUR BIT AU:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity FourBitAU_TB is
--  Port ( );
end FourBitAU_TB;

architecture Behavioral of FourBitAU_TB is

component FourBitAU is
    
    Port ( A_FBAU : in STD_LOGIC_VECTOR (3 downto 0);
           B_FBAU : in STD_LOGIC_VECTOR (3 downto 0);
           Cin_FBAU : in STD_LOGIC;
           G_FBAU : out STD_LOGIC_VECTOR (3 downto 0);
           Cout_FBAU : out STD_LOGIC;
           S0_FBAU : in STD_LOGIC;
           S1_FBAU : in STD_LOGIC);
end component;

signal A_FBAU : STD_LOGIC_VECTOR (3 downto 0);
signal B_FBAU : STD_LOGIC_VECTOR (3 downto 0);
signal Cin_FBAU : STD_LOGIC;
signal G_FBAU : STD_LOGIC_VECTOR (3 downto 0);
signal Cout_FBAU : STD_LOGIC;
signal S0_FBAU : STD_LOGIC;
signal S1_FBAU : STD_LOGIC;

begin

uut: FourBitAU port map (
    A_FBAU => A_FBAU,
    B_FBAU => B_FBAU,
    Cin_FBAU => Cin_FBAU,
    S0_FBAU => S0_FBAU,
    S1_FBAU => S1_FBAU,
    G_FBAU => G_FBAU,
    Cout_FBAU => Cout_FBAU
);

stim_proc : process
begin

wait for 65ns;

-- F = A + B (Add) --
S0_FBAU <= '0';
S1_FBAU <= '0';
Cin_FBAU <= '0';
A_FBAU <= "0111";
B_FBAU <= "0101";
wait for 65ns;

-- F = A' + B (Add) --
S0_FBAU <= '1';
S1_FBAU <= '0';
Cin_FBAU <= '0';
A_FBAU <= "0111";
B_FBAU <= "0101";
wait for 65ns;

-- F = A - 1 --
S0_FBAU <= '0';
S1_FBAU <= '1';
Cin_FBAU <= '0';
A_FBAU <= "0111";
B_FBAU <= "0101";
wait for 65ns;

-- F = A' --
S0_FBAU <= '1';
S1_FBAU <= '1';
Cin_FBAU <= '0';
A_FBAU <= "0111";
B_FBAU <= "0101";
wait for 65ns;

-- F = A + (B' + 1) => A + (2's comp B) => A - B --
S0_FBAU <= '0';
S1_FBAU <= '0';
Cin_FBAU <= '1';
A_FBAU <= "0111";
B_FBAU <= "0101";
wait for 65ns;

-- F = (A' + 1) + B => B + (2's comp A) => B - A --
S0_FBAU <= '1';
S1_FBAU <= '0';
Cin_FBAU <= '1';
A_FBAU <= "0111";
B_FBAU <= "0101";
wait for 65ns;

-- F = A + 1 --
S0_FBAU <= '0';
S1_FBAU <= '1';
Cin_FBAU <= '1';
A_FBAU <= "0111";
B_FBAU <= "0101";
wait for 65ns;

-- F = A' + 1 --
S0_FBAU <= '1';
S1_FBAU <= '1';
Cin_FBAU <= '1';
A_FBAU <= "0111";
B_FBAU <= "0101";
wait for 65ns;

wait;

end process; 

end Behavioral;`
      },
      {
        id: "6BitAdder",
        name: "6-Bit Adder",
        summary: [
          "<u><b>Building Process</b></u>",
          "This project involved designing a hierarchical <b>6-bit Ripple Carry Adder</b> in <b>VHDL</b>, composed of <b>Half Adders</b>, <b>Full Adders</b>, and a <b>Six-Bit Adder</b> module. The design incorporated a <b>Carry-In</b> and <b>Carry-Out</b> feature, with results displayed using a <b>7-Segment Display Decoder</b>. A <b>top-level module</b> integrated input switches, LED indicators, and real-time display multiplexing logic. The design was implemented in <b>Xilinx ISE</b>, verified with <b>test benches</b>, and simulated before being deployed on an <b>FPGA board</b>.",
          "<u><b>Project Impact</b></u>",
          "This project strengthened knowledge of <b>ripple carry adders</b> and <b>hierarchical hardware design</b>. It provided hands-on experience with <b>multi-bit arithmetic circuits</b>, <b>carry propagation</b>, and <b>real-time output interfacing</b> using a 7-segment display. The modular approach improved debugging, simulation, and hardware validation skills essential for building scalable digital systems.",
          "<u><b>Key Skills:</b></u> VHDL | Ripple Carry Adder Design | Hierarchical Design | Xilinx ISE | FPGA | Half & Full Adders | 7-Segment Display Multiplexing | Modular Architecture | Test Bench Development | Hardware Simulation & Verification"
        ],
        images: ["assets/RCS_L1_1.png", "assets/RCS_L1_2.png", "assets/RCS_L1_3.png", "assets/RCS_L1_4.png", "assets/RCS_L1_5.png", "assets/RCS_L1_6.png", "assets/RCS_L1_7.png", "assets/RCS_L1_8.png", "assets/RCS_L1_9.png", "assets/RCS_L1_10.png"],
        videos: [],
        downloads: ["downloads/RCS_L1.zip"],
        links: [{ label: "GitHub Repository", url: "https://github.com/Aamir-Ir/VHDL_Achievements/tree/main/VHDL%20-%20Intermediate/6%20-%20Bit%20Adder"}],
        code: `-- VHDL SOURCE CODE FILE FOR TOP MOST MODULE (HIERARCHICAL DESIGN) SEVEN SEGMENT DECODER FOR 6-BIT ADDER (RCS_L1):
----------------------------------------------------------------------------------
-- VHDL CODE FOR TOP MODULE:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use IEEE.std_logic_unsigned.all;

entity Top_Module is
    generic (N_BITS : integer := 6);

    Port (
        clk : in STD_LOGIC;
        SW : in STD_LOGIC_VECTOR(11 downto 0);
        LED : out STD_LOGIC_VECTOR(11 downto 0);
        AN : out STD_LOGIC_VECTOR(7 downto 0);
        Cathode : out STD_LOGIC_VECTOR(6 downto 0);
        carryLED : out STD_LOGIC;
        CarryInButton : in STD_LOGIC
    );
end Top_Module;

architecture Behavioral of Top_Module is
    signal sum : STD_LOGIC_VECTOR(6 downto 0); --changed range
    signal carry_out : STD_LOGIC;

    signal lowBits : STD_LOGIC_VECTOR(3 downto 0);
    signal highBits : STD_LOGIC_VECTOR(3 downto 0);
    
    signal lowSegmentDis : STD_LOGIC_VECTOR (6 downto 0);
    signal highSegmentDis : STD_LOGIC_VECTOR (6 downto 0);
    
    signal num : STD_LOGIC := '0';
    signal counter : integer range 0 to 32000 := 0;

begin
    carryLED <= carry_out;  -- using the first LED as carry indicator
    LED(11 downto 0) <= SW(11 downto 0);
    -- Instantiate the ripple carry adder
    Adder : entity work.SixBitAdder port map (
        A_SBA => SW(5 downto 0),
        B_SBA => SW(11 downto 6),
        Sum_SBA => sum(5 downto 0),  -- Changed this line
        CarryIn_SBA => CarryInButton,
        CarryOut_SBA => carry_out
    );
    
    sum(6) <= carry_out; --added

    lowBits <= sum(3 downto 0);

    highBits <= "0" & sum(6 downto 4); --changed to sum6
    
    decode_low : entity work.BCD_7SegDecoder port map (
            Input_7SD => lowBits,
            a_to_g => lowSegmentDis
    );
    
    decode_high : entity work.BCD_7SegDecoder port map (
                Input_7SD => highBits,
                a_to_g => highSegmentDis
    );
    
    process(clk)
        begin
        if rising_edge(clk) then
            if counter >= 5000 then --5 ms assuming 100 MHz clock
                if num = '0' then
                    num <= '1';
                    AN <= "11111110";  -- rightmost digit
                    Cathode <= lowSegmentDis;
                else
                    num <= '0';  -- This line was the problem
                    AN <= "11111101";  -- second rightmost digit
                    Cathode <= highSegmentDis;
                end if;
                counter <= 0;
            else
                counter <= counter + 1;
            end if;
        end if;
    end process;
        
            
end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR 7-SEGMENT DECODER:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity BCD_7SegDecoder is
    Port ( Input_7SD : in STD_LOGIC_VECTOR (3 downto 0);
           a_to_g : out STD_LOGIC_VECTOR (6 downto 0));
end BCD_7SegDecoder;

architecture Behavioral of BCD_7SegDecoder is

begin
   process(Input_7SD)
   begin   
     case Input_7SD is                                  -- a,b,c,d,e,f,g
         when "0000" => a_to_g <= "1000000"; --0
         when "0001" => a_to_g <= "1111001"; --1        1001111         1111001
         when "0010" => a_to_g <= "0100100"; --2     0010010  0100100
         when "0011" => a_to_g <= "0110000"; --3         
         when "0100" => a_to_g <= "0011001"; --4         
         when "0101" => a_to_g <= "0010010"; --5             
         when "0110" => a_to_g <= "0000010"; --6 
         when "0111" => a_to_g <= "1011000"; --7
         when "1000" => a_to_g <= "0000000"; --8
         when "1001" => a_to_g <= "0010000"; --9         
         when "1010" => a_to_g <= "0001000"; --A
         when "1011" => a_to_g <= "0000011"; --b         
         when "1100" => a_to_g <= "1000110"; --C         z
         when "1101" => a_to_g <= "0100001"; --d    
         when "1110" => a_to_g <= "0000110"; --E    
         when "1111" => a_to_g <= "0001110"; --F    
     end case;
   end process;
end Behavioral;


----------------------------------------------------------------------------------
-- VHDL CODE FOR 6-BIT ADDER:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity SixBitAdder is
    generic (N_BITS : integer := 6);

    Port ( A_SBA : in STD_LOGIC_VECTOR (N_BITS-1 downto 0);
           B_SBA : in STD_LOGIC_VECTOR (N_BITS-1 downto 0);
           Sum_SBA : out STD_LOGIC_VECTOR (N_BITS-1 downto 0);
           CarryIn_SBA : in STD_LOGIC;
           CarryOut_SBA : out STD_LOGIC);
end SixBitAdder;

architecture Behavioral of SixBitAdder is

component FullAdder is
    Port ( A_Full : in STD_LOGIC;
           B_Full : in STD_LOGIC;
           CarryIn_Full : in STD_LOGIC;
           Sum_Full : out STD_LOGIC;
           CarryOut_Full : out STD_LOGIC);
end component FullAdder;

signal Carry : STD_LOGIC_VECTOR(N_BITS downto 0) := (others => '0'); --Set

begin
    Carry(0) <= CarryIn_SBA;
    make_each_FA: for i in 0 to N_BITS-1 generate            -- Loop through each 1 bit adder and port everything.
        signal CarryOut_i : STD_LOGIC;                       -- This will catch each output of every carry out for each 1 bit adder.
    begin
        FullAdder_inst : FullAdder                           -- hierarchy for FA + port (Make sure to look at the circuit and understnad each ports.)
            port map (
                A_Full => A_SBA(i),                          -- A(N) passed.
                B_Full => B_SBA(i),                          -- B(N) passed.
                CarryIn_Full => Carry(i),                       -- Previous Carry in passed in from the update or 0 initally.
                Sum_Full => Sum_SBA(i),                      -- Sum_SBA(i) passed out.
                CarryOut_Full => CarryOut_i                  -- CarryOut_i updated.
            );
            Carry(i+1) <= CarryOut_i;         		     -- Setting the updated CarryOut_i as input for the next Full Adder.
     end generate make_each_FA;
     
     CarryOut_SBA <= Carry(N_BITS);
end Behavioral;

----------------------------------------------------------------------------------
-- VHDL CODE FOR FULL ADDER:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity FullAdder is
    Port ( A_Full : in STD_LOGIC;
           B_Full : in STD_LOGIC;
           CarryIn_Full : in STD_LOGIC;
           Sum_Full : out STD_LOGIC;
           CarryOut_Full : out STD_LOGIC);
end FullAdder;

architecture Behavioral of FullAdder is

    component HalfAdder is
        Port ( A_Half : in STD_LOGIC;
               B_Half : in STD_LOGIC;
               Sum_Half : out STD_LOGIC;
               CarryOut_Half : out STD_LOGIC);
    end component HalfAdder;
    
    signal sum_half_tmp : STD_LOGIC;
    signal CarryOut_half0 : STD_LOGIC;
    signal CarryOut_half1 : STD_LOGIC;
        
begin

    ha1: HalfAdder
        port map(A_Half => A_Full, B_Half => B_Full, Sum_Half => sum_half_tmp, CarryOut_Half => CarryOut_half0);

    ha2: HalfAdder
        port map(A_Half => sum_half_tmp, B_Half => CarryIn_Full, Sum_Half => Sum_Full, CarryOut_Half => CarryOut_half1);
        
    CarryOut_Full <= CarryOut_half1 OR CarryOut_half0;
end Behavioral;
        
----------------------------------------------------------------------------------
-- VHDL CODE FOR HALF ADDER:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity HalfAdder is
    Port ( A_Half : in STD_LOGIC;
           B_Half : in STD_LOGIC;
           Sum_Half : out STD_LOGIC;
           CarryOut_Half : out STD_LOGIC);
end HalfAdder;

architecture Behavioral of HalfAdder is

begin

    CarryOut_Half <= A_Half AND B_Half;
    Sum_Half <= A_Half XOR B_Half;

end Behavioral;
----------------------------------------------------------------------------------
-- VHDL CODE FOR TEST BENCH FOR THE TOP MODULE:
----------------------------------------------------------------------------------


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity lab1_tb is
--  Port ( );
end lab1_tb;

architecture Behavioral of lab1_tb is

--generic (N_BITS : integer := 6);
Component SixBitAdder
    Port ( A_SBA : in STD_LOGIC_VECTOR (5 downto 0);
           B_SBA : in STD_LOGIC_VECTOR (5 downto 0);
           Sum_SBA : out STD_LOGIC_VECTOR (5 downto 0);
           CarryIn_SBA : in STD_LOGIC;
           CarryOut_SBA : out STD_LOGIC);
end component;

signal A_SBA : std_logic_vector(5 downto 0) := (others => '0');
signal B_SBA : std_logic_vector(5 downto 0) := (others => '0');
signal CarryIn_SBA : std_logic := '0';

signal Sum_SBA : std_logic_vector(5 downto 0);
signal CarryOut_SBA : std_logic;

begin

uut: SixBitAdder port map (

A_SBA => A_SBA,
B_SBA => B_SBA,
CarryIn_SBA => CarryIn_SBA,
Sum_SBA => Sum_SBA,
CarryOut_SBA => CarryOut_SBA
);

stim_proc : process
begin
wait for 100ns;
A_SBA <= "000110";
B_SBA <= "001100";
CarryIn_SBA <= '0';

wait for 100ns;
A_SBA <= "110100";
B_SBA <= "010001";
CarryIn_SBA <= '0';

wait for 100ns;
A_SBA <= "101010";
B_SBA <= "010101";
CarryIn_SBA <= '1';

wait for 100ns;
A_SBA <= "100110";
B_SBA <= "011001";
CarryIn_SBA <= '1';

wait for 100ns;
A_SBA <= "111100";
B_SBA <= "111000";
CarryIn_SBA <= '0';

wait for 100ns;
A_SBA <= "111111";
B_SBA <= "111111";
CarryIn_SBA <= '1';

wait for 100ns;
A_SBA <= "000000";
B_SBA <= "000000";
CarryIn_SBA <= '0';

wait for 100ns;
A_SBA <= "111100";
B_SBA <= "111010";
CarryIn_SBA <= '1';

wait;
end process;


end Behavioral;`
      },
      {
        id: "ALU_2",
        name: "Simple ALU",
        summary: [
          "<u><b>Building Process</b></u>",
          "This project involved designing a hierarchical <b>4-bit Arithmetic Logic Unit (ALU)</b> in <b>VHDL</b>, integrating both <b>arithmetic</b> and <b>logic circuits</b>. The ALU supported multiple operations controlled by selection inputs and produced results displayed through a <b>7-Segment Display Decoder</b>. The design was created in <b>Xilinx ISE</b>, verified using detailed <b>test benches</b>, and simulated to validate arithmetic and logical operations before deployment on an <b>FPGA board</b>.",
          "<u><b>Project Impact</b></u>",
          "This project deepened understanding of <b>ALU architecture</b> and <b>hierarchical VHDL design</b>. It provided hands-on experience in combining arithmetic and logic modules, developing selection-controlled operations, and interfacing with a display for real-time output. The process enhanced skills in modular design, simulation, debugging, and FPGA hardware validation, all of which are fundamental in digital systems engineering.",
          "<u><b>Key Skills:</b></u> VHDL | ALU Design | Hierarchical Design | Xilinx ISE | FPGA | Arithmetic & Logic Circuits | 7-Segment Display | Modular Design | Test Bench Development | Hardware Simulation & Verification."
        ],
        images: ["assets/DS_L7_1.png", "assets/DS_L7_2.png", "assets/DS_L7_3.png", "assets/DS_L7_4.png", "assets/DS_L7_5.png", "assets/DS_L7_6.png", "assets/DS_L7_7.png", "assets/DS_L7_8.png", "assets/DS_L7_9.png", "assets/DS_L7_10.png", "assets/DS_L7_11.png", "assets/DS_L7_12.png", "assets/DS_L7_13.png", "assets/DS_L7_14.png", "assets/DS_L7_15.png", "assets/DS_L7_16.png", "assets/DS_L7_17.png"],
        videos: [],
        downloads: ["downloads/DS_L7.zip"],
        links: [{ label: "GitHub Repository", url: "https://github.com/Aamir-Ir/VHDL_Achievements/tree/main/VHDL%20-%20Beginner/ALU"}],
        code: `-- VHDL SOURCE CODE FILE FOR TOP MOST MODULE (HIERARCHICAL DESIGN) SEVEN SEGMENT DECODER FOR 4-BIT ALU (DS_L7):
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity SevenSegmentDecoder is
    Port ( A_SSD : in  STD_LOGIC_VECTOR (3 downto 0);
			  B_SSD : in  STD_LOGIC_VECTOR (3 downto 0);
			  Cin_SSD : in  STD_LOGIC;
           S0_SSD : in  STD_LOGIC;
           S1_SSD : in  STD_LOGIC;
           S2_SSD : in  STD_LOGIC;
           Target_SSD : out  STD_LOGIC_VECTOR (3 downto 0);
           Output_SSD : out  STD_LOGIC_VECTOR (6 downto 0));
end SevenSegmentDecoder;

architecture Structural of SevenSegmentDecoder is

component FourBitALU is
	Port ( A_ALU : in  STD_LOGIC_VECTOR(3 downto 0);
           B_ALU : in  STD_LOGIC_VECTOR(3 downto 0);
           Cin_ALU : in  STD_LOGIC;
           S0_ALU : in  STD_LOGIC;
           S1_ALU : in  STD_LOGIC;
           S2_ALU : in  STD_LOGIC;
           Cout_ALU : out  STD_LOGIC := '0';
           G_ALU : out  STD_LOGIC_VECTOR(3 downto 0));
end component;

SIGNAL Carry: STD_LOGIC;
SIGNAL G_SSD  :  STD_LOGIC_VECTOR (3 downto 0);

begin
ALU : FourBitALU PORT MAP (A_ALU=> A_SSD, B_ALU=> B_SSD, Cin_ALU=>Cin_SSD, S0_ALU=>S0_SSD, S1_ALU=>S1_SSD, S2_ALU=>S2_SSD, Cout_ALU=>Carry, G_ALU=> G_SSD);

Target_SSD<="0111";
Output_SSD <=
    "0000001" WHEN (G_SSD = "0000") ELSE
    "1001111" WHEN (G_SSD = "0001") ELSE
    "0010010" WHEN (G_SSD = "0010") ELSE
    "0000110" WHEN (G_SSD = "0011") ELSE
    "1001100" WHEN (G_SSD = "0100") ELSE
    "0100100" WHEN (G_SSD = "0101") ELSE
    "0100000" WHEN (G_SSD = "0110") ELSE
    "0001111" WHEN (G_SSD = "0111") ELSE
    "0000000" WHEN (G_SSD = "1000") ELSE
    "0000100" WHEN (G_SSD = "1001") ELSE
    "0001000" WHEN (G_SSD = "1010") ELSE
    "1100000" WHEN (G_SSD = "1011") ELSE
    "0110001" WHEN (G_SSD = "1100") ELSE
    "1000010" WHEN (G_SSD = "1101") ELSE
    "0110000" WHEN (G_SSD = "1110") ELSE
    "0111000" WHEN (G_SSD = "1111");

end Structural;

----------------------------------------------------------------------------------
-- VHDL CODE FOR FOUR BIT ALU:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity FourBitALU is
    Port ( A_ALU : in  STD_LOGIC_VECTOR(3 downto 0);
           B_ALU : in  STD_LOGIC_VECTOR(3 downto 0);
           Cin_ALU : in  STD_LOGIC;
           S0_ALU : in  STD_LOGIC;
           S1_ALU : in  STD_LOGIC;
           S2_ALU : in  STD_LOGIC;
           Cout_ALU : out  STD_LOGIC := '0';
           G_ALU : out  STD_LOGIC_VECTOR(3 downto 0));
end FourBitALU;

architecture Structural of FourBitALU is

component LogicCircuit is
	Port ( A_LC : in  STD_LOGIC_VECTOR (3 downto 0);
           B_LC : in  STD_LOGIC_VECTOR (3 downto 0);
           S0_LC : in  STD_LOGIC;
           S1_LC : in  STD_LOGIC;
           G_LC : out  STD_LOGIC_VECTOR (3 downto 0));
	end component;
	
component ArithmeticCircuit is
	Port ( Ain_AC : in  STD_LOGIC_VECTOR (3 downto 0);
           Bin_AC : in  STD_LOGIC_VECTOR (3 downto 0);
           S0_AC : in  STD_LOGIC;
           S1_AC : in  STD_LOGIC;
           Cout_AC : out  STD_LOGIC;
           G_AC : out  STD_LOGIC_VECTOR (3 downto 0);
           Cin_AC : in  STD_LOGIC);
	end component;

SIGNAL Cout_AC_TMP : STD_LOGIC;
SIGNAL G_AC_TMP,G_LC_TMP : STD_LOGIC_VECTOR (3 downto 0);

begin

	LC : LogicCircuit PORT MAP(A_LC=> A_ALU, B_LC=> B_ALU, S0_LC=> S0_ALU, S1_LC=> S1_ALU, G_LC=> G_LC_TMP);
	AC : ArithmeticCircuit PORT MAP(Ain_AC=> A_ALU, Bin_AC=> B_ALU, S0_AC=> S0_ALU, S1_AC=> S1_ALU, Cout_AC=> Cout_AC_TMP, G_AC=> G_AC_TMP, Cin_AC=>Cin_ALU );
	
	process(S2_ALU,G_AC_TMP,G_LC_TMP,Cout_AC_TMP)
		begin
		if (S2_ALU = '0') then
			G_ALU<=G_AC_TMP;
			Cout_ALU<=Cout_AC_TMP;
		else
			G_ALU<=G_LC_TMP;
		end if;
	end process;
	
end Structural;

----------------------------------------------------------------------------------
-- VHDL CODE FOR LOGIC MULTIPLEXER:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity LogicMultiplexer is
    Port ( A_LM : in  STD_LOGIC;
           B_LM : in  STD_LOGIC;
           S0_LM : in  STD_LOGIC;
           S1_LM : in  STD_LOGIC;
           G_LM : out  STD_LOGIC);
end LogicMultiplexer;

architecture Structural of LogicMultiplexer is

begin

  G_LM <= (A_LM and B_LM) when (S1_LM = '0' and S0_LM = '0')
					else (A_LM or B_LM) when (S1_LM = '0' and S0_LM = '1')
					else (A_LM xor B_LM) when (S1_LM = '1' and S0_LM = '0')
					else (not A_LM) when (S1_LM = '1' and S0_LM = '1');

end Structural;

----------------------------------------------------------------------------------
-- VHDL CODE FOR LOGIC CIRCUIT:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity LogicCircuit is
    Port ( A_LC : in  STD_LOGIC_VECTOR (3 downto 0);
           B_LC : in  STD_LOGIC_VECTOR (3 downto 0);
           S0_LC : in  STD_LOGIC;
           S1_LC : in  STD_LOGIC;
           G_LC : out  STD_LOGIC_VECTOR (3 downto 0));
end LogicCircuit;

architecture Structural of LogicCircuit is

component LogicMultiplexer is
	Port ( A_LM : in  STD_LOGIC;
           B_LM : in  STD_LOGIC;
           S0_LM : in  STD_LOGIC;
           S1_LM : in  STD_LOGIC;
           G_LM : out  STD_LOGIC);
	end component;

begin

MUX1:LogicMultiplexer PORT MAP(A_LM=>A_LC(0), B_LM=>B_LC(0),S0_LM=>S0_LC,S1_LM=>S1_LC,G_LM=>G_LC(0));
MUX2:LogicMultiplexer PORT MAP(A_LM=>A_LC(1), B_LM=>B_LC(1),S0_LM=>S0_LC,S1_LM=>S1_LC,G_LM=>G_LC(1));
MUX3:LogicMultiplexer PORT MAP(A_LM=>A_LC(2), B_LM=>B_LC(2),S0_LM=>S0_LC,S1_LM=>S1_LC,G_LM=>G_LC(2));
MUX4:LogicMultiplexer PORT MAP(A_LM=>A_LC(3), B_LM=>B_LC(3),S0_LM=>S0_LC,S1_LM=>S1_LC,G_LM=>G_LC(3));

end Structural;

----------------------------------------------------------------------------------
-- VHDL CODE FOR ARITHMETIC CIRCUIT:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity ArithmeticCircuit is
    Port ( Ain_AC : in  STD_LOGIC_VECTOR (3 downto 0);
           Bin_AC : in  STD_LOGIC_VECTOR (3 downto 0);
           S0_AC : in  STD_LOGIC;
           S1_AC : in  STD_LOGIC;
           Cout_AC : out  STD_LOGIC;
           G_AC : out  STD_LOGIC_VECTOR (3 downto 0);
           Cin_AC : in  STD_LOGIC);
end ArithmeticCircuit;

architecture Structural of ArithmeticCircuit is

component ArithmeticLogicB is
	Port ( S1_AL : in  STD_LOGIC;
           S0_AL : in  STD_LOGIC;
           Bin_AL : in  STD_LOGIC_VECTOR (3 downto 0);
           Bout_AL : out  STD_LOGIC_VECTOR (3 downto 0));
	end component;

component FullAdder is
	Port ( A_FA : in  STD_LOGIC;
           B_FA : in  STD_LOGIC;
           Cin_FA : in  STD_LOGIC;
           Sum_FA : out  STD_LOGIC;
           Cout_FA : out  STD_LOGIC);
	end component;
	
	SIGNAL Bpostlogic:STD_LOGIC_VECTOR (3 downto 0);
	SIGNAL C1,C2,C3: STD_LOGIC;

	
begin

BLogic:ArithmeticLogicB PORT MAP(S1_AL=>S1_AC, S0_AL=>S0_AC,Bin_AL=>Bin_AC,Bout_AL=>Bpostlogic);
FA1:FullAdder PORT MAP(A_FA => Ain_AC(0),B_FA => Bpostlogic(0), Cin_FA => Cin_AC, Sum_FA => G_AC(0),Cout_FA => C1);
FA2:FullAdder PORT MAP(A_FA => Ain_AC(1),B_FA => Bpostlogic(1), Cin_FA => C1, Sum_FA => G_AC(1),Cout_FA => C2);
FA3:FullAdder PORT MAP(A_FA => Ain_AC(2),B_FA => Bpostlogic(2), Cin_FA => C2, Sum_FA => G_AC(2),Cout_FA => C3);
FA4:FullAdder PORT MAP(A_FA => Ain_AC(3),B_FA => Bpostlogic(3), Cin_FA => C3, Sum_FA => G_AC(3),Cout_FA => Cout_AC);


end Structural;

----------------------------------------------------------------------------------
-- VHDL CODE FOR LOGIC MULTIPLEXER:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity LogicMultiplexer is
    Port ( A_LM : in  STD_LOGIC;
           B_LM : in  STD_LOGIC;
           S0_LM : in  STD_LOGIC;
           S1_LM : in  STD_LOGIC;
           G_LM : out  STD_LOGIC);
end LogicMultiplexer;

architecture Structural of LogicMultiplexer is

begin

  G_LM <= (A_LM and B_LM) when (S1_LM = '0' and S0_LM = '0')
					else (A_LM or B_LM) when (S1_LM = '0' and S0_LM = '1')
					else (A_LM xor B_LM) when (S1_LM = '1' and S0_LM = '0')
					else (not A_LM) when (S1_LM = '1' and S0_LM = '1');

end Structural;

----------------------------------------------------------------------------------
-- VHDL CODE FOR ONE BIT ALU:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity OneBitALU is
	Port ( A_OBALU : in  STD_LOGIC;
           B_OBALU : in  STD_LOGIC;
           Cin_OBALU : in  STD_LOGIC;
           S0_OBALU : in  STD_LOGIC;
           S1_OBALU : in  STD_LOGIC;
           S2_OBALU : in  STD_LOGIC;
           Cout_OBALU : out  STD_LOGIC;
           G_OBALU : out  STD_LOGIC);
end OneBitALU;

architecture Structural of OneBitALU is

component LogicCircuit is
	Port ( A_LC : in  STD_LOGIC_VECTOR (3 downto 0);
           B_LC : in  STD_LOGIC_VECTOR (3 downto 0);
           S0_LC : in  STD_LOGIC;
           S1_LC : in  STD_LOGIC;
           G_LC : out  STD_LOGIC_VECTOR (3 downto 0));
	end component;
	
component ArithmeticCircuit is
	Port ( Ain_AC : in  STD_LOGIC_VECTOR (3 downto 0);
           Bin_AC : in  STD_LOGIC_VECTOR (3 downto 0);
           S0_AC : in  STD_LOGIC;
           S1_AC : in  STD_LOGIC;
           Cout_AC : out  STD_LOGIC;
           G_AC : out  STD_LOGIC_VECTOR (3 downto 0);
           Cin_AC : in  STD_LOGIC);
	end component;

begin


end Structural;

----------------------------------------------------------------------------------
-- VHDL CODE FOR ArithmeticLogicB:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity ArithmeticLogicB is
    Port ( S1_AL : in  STD_LOGIC;
           S0_AL : in  STD_LOGIC;
           Bin_AL : in  STD_LOGIC_VECTOR (3 downto 0);
           Bout_AL : out  STD_LOGIC_VECTOR (3 downto 0));
end ArithmeticLogicB;

architecture Structural of ArithmeticLogicB is

begin

	Bout_AL <= "0000" when (S1_AL = '0' and S0_AL = '0')
					else Bin_AL when (S1_AL = '0' and S0_AL = '1')
					else (not Bin_AL) when (S1_AL = '1' and S0_AL = '0')
					else "1111" when (S1_AL = '1' and S0_AL = '1');

end Structural;

----------------------------------------------------------------------------------
-- VHDL CODE FOR FULL ADDER:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity FullAdder is
    Port ( A_FA : in  STD_LOGIC;
           B_FA : in  STD_LOGIC;
           Cin_FA : in  STD_LOGIC;
           Sum_FA : out  STD_LOGIC;
           Cout_FA : out  STD_LOGIC);
end FullAdder;

architecture Structural of FullAdder is

	component HalfAdder is
	Port ( A,B : in STD_LOGIC;
			Sum,Cout : out STD_LOGIC);
	end component;
	
	SIGNAL S0,S1,S2:STD_LOGIC;
	
begin
HA1:HalfAdder PORT MAP(A=>A_FA,B=>B_FA,Sum=>S0,Cout=>S1);
HA2:HalfAdder PORT MAP(A=>S0,B=>Cin_FA,Sum=>Sum_FA,Cout=>S2);

Cout_FA<=S2 or S1;

end Structural;

----------------------------------------------------------------------------------
-- VHDL CODE FOR HALF ADDER:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity HalfAdder is
    Port ( A : in  STD_LOGIC;
           B : in  STD_LOGIC;
           Sum : out  STD_LOGIC;
           Cout : out  STD_LOGIC);
end HalfAdder;

architecture Structural of HalfAdder is

begin
	Sum <= A xor B;
   Cout <= A and B;

end Structural;

--------------------------------------------------------------------------------
-- VHDL TEST BENCH CODE FOR 4-BIT ALU:
----------------------------------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
 
-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--USE ieee.numeric_std.ALL;
 
ENTITY ALU_TB IS
END ALU_TB;
 
ARCHITECTURE behavior OF ALU_TB IS 
 
    -- Component Declaration for the Unit Under Test (UUT)
 
    COMPONENT SevenSegmentDecoder
    PORT(
         A_SSD : IN  std_logic_vector(3 downto 0);
         B_SSD : IN  std_logic_vector(3 downto 0);
         Cin_SSD : IN  std_logic;
         S0_SSD : IN  std_logic;
         S1_SSD : IN  std_logic;
         S2_SSD : IN  std_logic;
         Target_SSD : OUT  std_logic_vector(3 downto 0);
         Output_SSD : OUT  std_logic_vector(6 downto 0)
        );
    END COMPONENT;
    

   --Inputs
   signal A_SSD : std_logic_vector(3 downto 0) := (others => '0');
   signal B_SSD : std_logic_vector(3 downto 0) := (others => '0');
   signal Cin_SSD : std_logic := '0';
   signal S0_SSD : std_logic := '0';
   signal S1_SSD : std_logic := '0';
   signal S2_SSD : std_logic := '0';

 	--Outputs
   signal Target_SSD : std_logic_vector(3 downto 0);
   signal Output_SSD : std_logic_vector(6 downto 0);
   -- No clocks detected in port list. Replace <clock> below with 
   -- appropriate port name 

 
BEGIN
 
	-- Instantiate the Unit Under Test (UUT)
   uut: SevenSegmentDecoder PORT MAP (
          A_SSD => A_SSD,
          B_SSD => B_SSD,
          Cin_SSD => Cin_SSD,
          S0_SSD => S0_SSD,
          S1_SSD => S1_SSD,
          S2_SSD => S2_SSD,
          Target_SSD => Target_SSD,
          Output_SSD => Output_SSD
        );

   -- Clock process definitions

 

   -- Stimulus process
   stim_proc: process
   begin	

--testing arithmetic circuit
		S0_SSD <= '0';
		S1_SSD <= '0';
		Cin_SSD <= '0';
		A_SSD <= "0111";
		B_SSD <= "0101";
      wait for 65 ns;	
		
		S0_SSD <= '0';
		S1_SSD <= '0';
		Cin_SSD <= '1';
		wait for 65 ns;
		
		S0_SSD <= '0';
		S1_SSD <= '1';
		Cin_SSD <= '0';
		wait for 65 ns;
		
		S0_SSD <= '0';
		S1_SSD <= '1';
		Cin_SSD <= '1';
		wait for 65 ns;
		
		S0_SSD <= '1';
		S1_SSD <= '0';
		Cin_SSD <= '0';
		wait for 65 ns;
		
		S0_SSD <= '1';
		S1_SSD <= '0';
		Cin_SSD <= '1';
		wait for 65 ns;
		
		S0_SSD <= '1';
		S1_SSD <= '1';
		Cin_SSD <= '0';
		wait for 65 ns;
		
		S0_SSD <= '1';
		S1_SSD <= '1';
		Cin_SSD <= '1';
		wait for 65 ns;

-- testing logic circuit
		S2_SSD <= '1';

      S0_SSD <= '0';
		S1_SSD <= '0';
		Cin_SSD <= '0';
      wait for 65 ns;	
		
		S0_SSD <= '0';
		S1_SSD <= '1';
		Cin_SSD <= '0';
		wait for 65 ns;
		
		
		S0_SSD <= '1';
		S1_SSD <= '0';
		Cin_SSD <= '0';
		wait for 65 ns;
	
		
		S0_SSD <= '1';
		S1_SSD <= '1';
		Cin_SSD <= '0';
		wait for 65 ns;
		

      wait;
   end process;

END;`
      },
      {
        id: "Sequential",
        name: "Sequential Circuit",
        summary: [
          "<u><b>Building Process</b></u>",
          "This project involved designing a <b>Sequential Circuit</b> in <b>VHDL</b> to recognize a specific input sequence using a <b>Finite State Machine (FSM)</b>. A <b>debouncer</b> module was integrated to ensure reliable input from mechanical switches. The design was implemented in <b>Xilinx ISE</b>, verified through a <b>test bench</b>, and simulated to validate correct state transitions and output behavior before being deployed on an <b>FPGA</b>.",
          "<u><b>Project Impact</b></u>",
          "This project reinforced practical knowledge of <b>sequential logic</b> and <b>FSM-based design</b> in hardware. It provided hands-on experience with reliable input handling, simulation-based validation, and FPGA implementation. Additionally, it enhanced debugging, verification, and state machine design skills essential for digital system development.",
          "<u><b>Key Skills:</b></u> VHDL | Sequential Circuits | FSM Design | Xilinx ISE | FPGA | Debouncing | Test Bench Development | Simulation & Verification | Moore Machine | Mealy Machine."
        ],
        images: ["assets/DS_L6_1.png", "assets/DS_L6_2.png", "assets/DS_L6_3.png", "assets/DS_L6_4.png", "assets/DS_L6_5.png", "assets/DS_L6_6.png", "assets/DS_L6_7.png"],
        videos: [],
        downloads: ["downloads/DS_L6.zip"],
        links: [{ label: "GitHub Repository", url: "https://github.com/Aamir-Ir/VHDL_Achievements/tree/main/VHDL%20-%20Beginner/Sequence%20Recognizer"}],
        code: `-- VHDL SOURCE CODE FILE FOR TOP MOST MODULE (HIERARCHICAL DESIGN) SEQUENCE RECOGNIZER SEQUENTIAL CIRCUIT (DS_L6):
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity topmod is
    Port ( clk_topmod : in  STD_LOGIC;
				reset_topmod : in  STD_LOGIC;
           topmod_out : out  STD_LOGIC;
           input_topmod : in  STD_LOGIC;
			  btn_in : in  STD_LOGIC);
end topmod;

architecture Behavioral of topmod is
	component dbounce is
		Port ( push_bt : in  STD_LOGIC;
           cclk : in  STD_LOGIC;
           debounce_out : out  STD_LOGIC);
	end component dbounce;

	component SequenceRecongnizer_VHDL is
		Port ( clk : in  STD_LOGIC;
           reset : in  STD_LOGIC;
           X : in  STD_LOGIC;
           Y : out  STD_LOGIC);
	end component SequenceRecongnizer_VHDL;

signal tmp_clk : std_logic;

begin

dbounce_SR : dbounce
	port map(btn_in, clk_topmod, tmp_clk);

SR : SequenceRecongnizer_VHDL
	port map(tmp_clk, reset_topmod, input_topmod, topmod_out);

end Behavioral;
----------------------------------------------------------------------------------
-- DEBOUNCER CIRCUIT VHDL CODE:

----------------------------------------------------------------
-- This VHDL code can be used to debounce a key 
-- (switch or push button)in other words get
-- rid of the oscillations that might occur due 
-- to the mechanical nature of the switch.
-- One problem with using a mechanical switch 
-- is that when it is closed, it bounces for a 
-- few milliseconds (i.e it makes a number of 
-- very rapid make and break actions before the  
-- contacts become stable), which lets the CPU or FPGA 
-- see that it has been pressed several   
-- times, and gives the wrong information.
--
-- You can use the VHDL code by synthesizing it,
-- creating a symbol and using it within your    
-- schematics. 
-- The UFC file to be used should put the 
-- following in consideration:
-- 
-- The push_bt should be connected to the 
-- PUSH BUTTON ON THE FPGA e.g., C9 
-- The cclk should be connected to V10 
-- the main clock on the NEXYS3 FPGA Board
-- The debounce_out should be connected as a source
-- of the stable clock to run the machine
--
--
----------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.std_logic_unsigned.all;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity dbounce is
    Port ( push_bt : in  STD_LOGIC;
           cclk : in  STD_LOGIC;
           debounce_out : out  STD_LOGIC);
end dbounce;

architecture Behavioral of dbounce is
signal d1, d2, reset, cout : std_logic;
signal count : std_logic_vector(20 downto 0);
begin

reset <= d1 xor d2;

FF: process(cclk)
begin
if(cclk'event and cclk = '1') then
d1 <= push_bt;
d2 <= d1;
if(cout = '1') then
debounce_out <= d2;
end if;
end if;
end process;

CNTR: process(cclk, reset)
begin
if(reset='1') then
count <= (others=>'0');
elsif (cclk'event and cclk='1') then
if (cout = '0') then
count <= count + 1;
end if;
end if;
end process;

cout <= count(20);

end Behavioral;
----------------------------------------------------------------------------------
-- SEQUENCE RECOGNIZER VHDL CODE:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.std_logic_unsigned.all;

entity SequenceRecongnizer_VHDL is
    Port ( clk : in  STD_LOGIC;
           reset : in  STD_LOGIC;
           X : in  STD_LOGIC;
           Y : out  STD_LOGIC);
end SequenceRecongnizer_VHDL;

architecture Structural of SequenceRecongnizer_VHDL is
	type statetype is (A,B,C,D,E);
	signal present_state, next_state: statetype;
	
Begin

clk_process: process( reset, clk)
begin
	if reset = '1' then -- Check for reset and initialize state
		present_state <= A;
	Elsif (rising_edge(clk)) then -- wait until the rising edge
		present_state <= next_state;
	end if;
end process clk_process;


next_state_process: process( present_state, X) is
begin
	case present_state is -- depending upon current state
	when A => -- set next state
		if X = '0' then
			next_state <= A;
		else
			next_state <= B;
	end if;
		when B =>
			if X = '0' then
				next_state <= A;
			else
				next_state <= C;
	end if;
		when C =>
			if X = '0' then
				next_state <= D;
			else
				next_state <= C;
	end if;
		when D =>
			if X = '0' then
				next_state <= A;
			else
				next_state <= E;
	end if;
		when E =>
			if X = '0' then
				next_state <= A;
			else
				next_state <= C;
	end if;
	end case;
end process next_state_process;


output_process: process( present_state) is
begin
		case present_state is -- depending upon current state
		when A => -- set output signals
			Y<= '0';
		when B =>
			Y<= '0';
		when C =>
			Y<= '0';
		when D =>
			Y<= '0';
		when E =>
			Y<= '1';
		end case;
end process output_process;


end Structural;
----------------------------------------------------------------------------------
-- SEQUENCE RECOGNIZER TESTBENCH CODE:
----------------------------------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
 
-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--USE ieee.numeric_std.ALL;
 
ENTITY SequentialRecongnizer_VHDL_TB IS
END SequentialRecongnizer_VHDL_TB;
 
ARCHITECTURE behavior OF SequentialRecongnizer_VHDL_TB IS 
 
    -- Component Declaration for the Unit Under Test (UUT)
 
    COMPONENT SequenceRecongnizer_VHDL
    PORT(
         clk : IN  std_logic;
         reset : IN  std_logic;
         X : IN  std_logic;
         Y : OUT  std_logic
        );
    END COMPONENT;
    

   --Inputs
   signal clk : std_logic := '0';
   signal reset : std_logic := '0';
   signal X : std_logic := '0';

 	--Outputs
   signal Y : std_logic;

   -- Clock period definitions
   constant clk_period : time := 10 ns;
 
BEGIN
 
	-- Instantiate the Unit Under Test (UUT)
   uut: SequenceRecongnizer_VHDL PORT MAP (
          clk => clk,
          reset => reset,
          X => X,
          Y => Y
        );

   -- Clock process definitions
   clk_process :process
   begin
		clk <= '0';
		wait for clk_period/2;
		clk <= '1';
		wait for clk_period/2;
   end process;
 

   -- Stimulus process
   stim_proc: process
   begin		
	  X <= '0';
	  reset <= '1';
	  -- Wait 100 ns for global reset to finish
	  wait for 10 ns;
		reset <= '0';
	  wait for 10 ns;
	  X <= '1';
	  wait for 10 ns;
	  X <= '1';
	  wait for 10 ns;
	  X <= '1'; 
	  wait for 10 ns;
	  X <= '0'; 
	  wait for 10 ns;
	  X <= '1'; 
	  wait for 10 ns;
	  X <= '0'; 
      wait;
   end process;

END;`
      },
      {
        id: "FA",
        name: "4 Bit Adder",
        summary: [
          "<u><b>Building Process</b></u>",
          "This project involved designing a hierarchical <b>4-bit Full Adder/Subtractor</b> in <b>VHDL</b>, composed of <b>Half Adders</b>, <b>Full Adders</b>, and a <b>4-bit Adder-Subtractor</b> module. The output was connected to a <b>7-Segment Display Decoder</b> for real-time visualization of results. The design was developed in <b>Xilinx ISE</b>, verified with detailed <b>test benches</b>, and simulated to validate both addition and subtraction operations before being deployed on an <b>FPGA board</b>.",
          "<u><b>Project Impact</b></u>",
          "This project reinforced a strong understanding of <b>hierarchical digital design</b> and <b>modular architecture</b> in VHDL. It provided hands-on experience in combining arithmetic logic with display interfacing, testing through simulation, and validating hardware behavior on an FPGA. The structured, bottom-up design process improved debugging, verification, and hardware mapping skills essential in digital systems engineering.",
          "<u><b>Key Skills:</b></u> VHDL | Hierarchical Design | Xilinx ISE | FPGA | Full Adder & Subtractor Circuits | 7-Segment Display | Modular Design | Test Bench Development | Hardware Simulation & Verification."
        ],
        images: ["assets/DS_L5_6.png", "assets/DS_L5_5.png", "assets/DS_L5_4.png", "assets/DS_L5_3.png", "assets/DS_L5_2.png", "assets/DS_L5_1.png"],
        videos: [],
        downloads: ["downloads/DS_L5.zip"],
        links: [{ label: "GitHub Repository", url: "https://github.com/Aamir-Ir/VHDL_Achievements/tree/main/VHDL%20-%20Beginner/Full%20Adder_Subtractor%20(4%20Bit)"}],
        code: `-- VHDL SOURCE CODE FILE FOR TOP MOST MODULE (HIERARCHICAL DESIGN) 4-Bit Full Adder (DS_L5):
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity SevenSegmentDecoder is
    Port ( Operand_7SD : in  std_logic;
			  Input_7SD : inout std_logic_vector(3 downto 0);
			  A_7SD : in  std_logic_vector(3 downto 0);
			  B_7SD: in std_logic_vector(3 downto 0);
			  Output_7SD: out std_logic_vector(6 downto 0);
	        Segment_7SD: out std_logic_vector(3 downto 0));
end SevenSegmentDecoder;

architecture Structural of SevenSegmentDecoder is

	component FourBitAdderSubtractor is
		Port ( Operand_FBAS : in  STD_LOGIC;
           A_FBAS : in  STD_LOGIC_VECTOR(3 downto 0);
           B_FBAS : in  STD_LOGIC_VECTOR(3 downto 0);
           Sum_FBAS : out  STD_LOGIC_VECTOR(3 downto 0);
           CarryOut_FBAS : out  STD_LOGIC;
           Overflow_FBAS : out  STD_LOGIC);
	end component FourBitAdderSubtractor;

	signal CarryOut_7SD: std_logic;
	signal Overflow_7SD: std_logic;

begin

	FBAS : FourBitAdderSubtractor
		port map(Operand_7SD, A_7SD, B_7SD, Input_7SD, CarryOut_7SD, Overflow_7SD);

	Segment_7SD<= "0111";

	Output_7SD <= 
		"0000001" WHEN (Input_7SD = "0000") ELSE
		"1001111" WHEN (Input_7SD = "0001") ELSE
		"0010010" WHEN (Input_7SD = "0010") ELSE
		"0000110" WHEN (Input_7SD = "0011") ELSE
		"1001100" WHEN (Input_7SD = "0100") ELSE
		"0100100" WHEN (Input_7SD = "0101") ELSE
		"0100000" WHEN (Input_7SD = "0110") ELSE
		"0001111" WHEN (Input_7SD = "0111") ELSE
		"0000000" WHEN (Input_7SD = "1000") ELSE
		"0000100" WHEN (Input_7SD = "1001") ELSE
		"0001000" WHEN (Input_7SD = "1010") ELSE
		"1100000" WHEN (Input_7SD = "1011") ELSE
		"0110001" WHEN (Input_7SD = "1100") ELSE
		"1000010" WHEN (Input_7SD = "1101") ELSE
		"0110000" WHEN (Input_7SD = "1110") ELSE
		"0111000" WHEN (Input_7SD = "1111");

end Structural;       
----------------------------------------------------------------------------------
-- VHDL SOURCE CODE FILE FOR FOUR BIT ADDER SUBTRACTOR:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity FourBitAdderSubtractor is
    Port ( Operand_FBAS : in  STD_LOGIC;
           A_FBAS : in  STD_LOGIC_VECTOR(3 downto 0);
           B_FBAS : in  STD_LOGIC_VECTOR(3 downto 0);
           Sum_FBAS : out  STD_LOGIC_VECTOR(3 downto 0);
           CarryOut_FBAS : out  STD_LOGIC;
           Overflow_FBAS : out  STD_LOGIC);
end FourBitAdderSubtractor;

architecture Structural of FourBitAdderSubtractor is
	component FullAdder is
	Port ( A_Full : in  STD_LOGIC;
           B_Full : in  STD_LOGIC;
           CarryIn_Full : in  STD_LOGIC;
           CarryOut_Full : out  STD_LOGIC;
           Sum_Full : out  STD_LOGIC);	  
		  
	end component FullAdder;
	
	signal Carry1_FBAS, Carry2_FBAS, Carry3_FBAS, Carry4_FBAS : std_logic;
	signal TMP: std_logic_vector(3 downto 0);

begin
	TMP(0)<= Operand_FBAS xor B_FBAS(0);
	TMP(1)<= Operand_FBAS xor B_FBAS(1);
	TMP(2)<= Operand_FBAS xor B_FBAS(2);
	TMP(3)<= Operand_FBAS xor B_FBAS(3);
	
	FullAdder_0:FullAdder 
		port map(A_FBAS(0),TMP(0),Operand_FBAS,Carry1_FBAS, Sum_FBAS(0)); --- Sum_FBAS(0)
	
	FullAdder_1:FullAdder 
		port map(A_FBAS(1),TMP(1),Carry1_FBAS,Carry2_FBAS, Sum_FBAS(1)); --- Sum_FBAS(1)
	
	FullAdder_2:FullAdder 
		port map(A_FBAS(2),TMP(2),Carry2_FBAS,Carry3_FBAS, Sum_FBAS(2));-- - Sum_FBAS(2)
	
	FullAdder_3:FullAdder 
		port map(A_FBAS(3),TMP(3),Carry3_FBAS,Carry4_FBAS, Sum_FBAS(3));-- - Sum_FBAS(3)
	
	Overflow_FBAS <= Carry3_FBAS XOR Carry4_FBAS ;
	CarryOut_FBAS <= Carry4_FBAS;
	
end Structural;
----------------------------------------------------------------------------------
-- VHDL SOURCE CODE FILE FOR FULL ADDERS:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity FullAdder is
    Port ( A_Full : in  STD_LOGIC;
           B_Full : in  STD_LOGIC;
           CarryIn_Full : in  STD_LOGIC;
           CarryOut_Full : out  STD_LOGIC;
           Sum_Full : out  STD_LOGIC);
end FullAdder;

architecture Structural of FullAdder is
	signal M : STD_LOGIC;
	signal N : STD_LOGIC;
	signal P : STD_LOGIC;
	component HalfAdder is 
		Port ( A_Half : in  STD_LOGIC;
           B_Half : in  STD_LOGIC;
           Sum_Half : out  STD_LOGIC;
           CarryOut_Half : out  STD_LOGIC);
	end component HalfAdder;
begin
	ha1 : HalfAdder 
		port map (A_Half=>A_Full, B_Half=>B_Full , Sum_Half=> M, CarryOut_Half=>N);
					
	ha2 : HalfAdder 
		port map (A_Half=>M, B_Half=>CarryIn_Full , Sum_Half=> Sum_Full, CarryOut_Half=>P);
	CarryOut_Full<= P or N;
end Structural;
----------------------------------------------------------------------------------
-- VHDL SOURCE CODE FILE FOR HALF ADDERS:
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity HalfAdder is
    Port ( A_Half : in  STD_LOGIC;
           B_Half : in  STD_LOGIC;
           Sum_Half : out  STD_LOGIC;
           CarryOut_Half : out  STD_LOGIC);
end HalfAdder;

architecture Dataflow of HalfAdder is

begin

	Sum_Half <= A_Half xor B_Half;
	CarryOut_Half <= A_Half and B_Half;

end Dataflow;
----------------------------------------------------------------------------------
-- VHDL TEST BENCH CODE FOR FOUR BIT ADDER SUBTRACTOR:
----------------------------------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

ENTITY FourBitAdderSubtractor_TB IS
END FourBitAdderSubtractor_TB;
 
ARCHITECTURE behavior OF FourBitAdderSubtractor_TB IS
    COMPONENT FourBitAdderSubtractor
    PORT(
         Operand_FBAS : IN  std_logic;
         A_FBAS : IN  std_logic_vector(3 downto 0);
         B_FBAS : IN  std_logic_vector(3 downto 0);
         Sum_FBAS : OUT  std_logic_vector(3 downto 0);
         CarryOut_FBAS : OUT  std_logic;
         Overflow_FBAS : OUT  std_logic
        );
    END COMPONENT;
    
   --Inputs
   signal Operand_FBAS : std_logic := '0';
   signal A_FBAS : std_logic_vector(3 downto 0) := (others => '0');
   signal B_FBAS : std_logic_vector(3 downto 0) := (others => '0');
 	--Outputs
   signal Sum_FBAS : std_logic_vector(3 downto 0);
   signal CarryOut_FBAS : std_logic;
   signal Overflow_FBAS : std_logic;
 
   constant period : time := 10 ns;
 
BEGIN
   uut: FourBitAdderSubtractor PORT MAP (
          Operand_FBAS => Operand_FBAS,
          A_FBAS => A_FBAS,
          B_FBAS => B_FBAS,
          Sum_FBAS => Sum_FBAS,
          CarryOut_FBAS => CarryOut_FBAS,
          Overflow_FBAS => Overflow_FBAS
        );


   -- Stimulus process
   stim_proc: process
   begin		
	

 A_7SD <= "0000"; B_7SD <= "0101"; -- 0 + 5 => 05 (0 0101)
 WAIT FOR 100 ns;
 A_7SD <= "0001"; B_7SD <= "0111"; -- 1 + 7 => 08 (0 1000)
 WAIT FOR 100 ns;
 A_7SD <= "0010"; B_7SD <= "1001"; -- 2 + 9 => 0B (0 1011)
 WAIT FOR 100 ns;
 A_7SD <= "0011"; B_7SD <= "1011"; -- 3 + B => 0E (0 1110)
 WAIT FOR 100 ns;
 A_7SD <= "0100"; B_7SD <= "1101"; -- 4 + D => 11 (1 0001)
 WAIT FOR 100 ns;
 A_7SD <= "0101"; B_7SD <= "1111"; -- 5 + F => 14 (1 0100)
 WAIT FOR 100 ns;
 A_7SD <= "0110"; B_7SD <= "0001"; -- 6 + 1 => 07 (0 0111)
 WAIT FOR 100 ns;
 A_7SD <= "0111"; B_7SD <= "0011"; -- 7 + 3 => 0A (0 1010)
 WAIT FOR 100 ns;
 A_7SD <= "1000"; B_7SD <= "0101"; -- 8 + 5 => 0D (0 1101)
 WAIT FOR 100 ns;
 A_7SD <= "1001"; B_7SD <= "0111"; -- 9 + 7 => 10 (1 0000)



      wait;
   end process;

END;
----------------------------------------------------------------------------------
-- VHDL TEST BENCH CODE FOR 7 SEGMENT DISPLAY TESTING 4-BIT ADDER:
----------------------------------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

ENTITY SevenSegmentDecoder_TB IS
END SevenSegmentDecoder_TB;
 
ARCHITECTURE behavior OF SevenSegmentDecoder_TB IS 
 
    COMPONENT SevenSegmentDecoder
    PORT(
         Operand_7SD : IN  std_logic;
         Input_7SD : INOUT  std_logic_vector(3 downto 0);
         A_7SD : IN  std_logic_vector(3 downto 0);
         B_7SD : IN  std_logic_vector(3 downto 0);
         Output_7SD : OUT  std_logic_vector(6 downto 0);
         Segment_7SD : OUT  std_logic_vector(3 downto 0)
        );
    END COMPONENT;
    

   --Inputs
   signal Operand_7SD : std_logic := '0';
   signal A_7SD : std_logic_vector(3 downto 0) := (others => '0');
   signal B_7SD : std_logic_vector(3 downto 0) := (others => '0');

	--BiDirs
   signal Input_7SD : std_logic_vector(3 downto 0);

 	--Outputs
   signal Output_7SD : std_logic_vector(6 downto 0);
   signal Segment_7SD : std_logic_vector(3 downto 0);
 
   constant period : time := 20 ns;
 
BEGIN
 
	-- Instantiate the Unit Under Test (UUT)
   uut: SevenSegmentDecoder PORT MAP (
          Operand_7SD => Operand_7SD,
          Input_7SD => Input_7SD,
          A_7SD => A_7SD,
          B_7SD => B_7SD,
          Output_7SD => Output_7SD,
          Segment_7SD => Segment_7SD
        );

   -- Stimulus process
   stim_proc: process
   begin		
       
		 --addition
		 A_7SD <= "0000"; B_7SD <= "0101"; -- 0 + 5 => 05 (0 0101)
		 WAIT FOR 100 ns;
		 assert(Input_7SD = "0101")report "error on case" severity error;
		 A_7SD <= "0001"; B_7SD <= "0111"; -- 1 + 7 => 08 (0 1000)
		 WAIT FOR 100 ns;
		 assert(Input_7SD = "1000")report "error on case" severity error;
		 A_7SD <= "0010"; B_7SD <= "1001"; -- 2 + 9 => 0B (0 1011)
		 WAIT FOR 100 ns;
		 assert(Input_7SD = "1011")report "error on case" severity error;
		 A_7SD <= "0011"; B_7SD <= "1011"; -- 3 + B => 0E (0 1110)
		 WAIT FOR 100 ns;
		 assert(Input_7SD = "1110")report "error on case" severity error;
		 A_7SD <= "0100"; B_7SD <= "1101"; -- 4 + D => 11 (1 0001)
		 WAIT FOR 100 ns;
		 assert(Input_7SD = "0001")report "error on case" severity error;
		 A_7SD <= "0101"; B_7SD <= "1111"; -- 5 + F => 14 (1 0100)
		 WAIT FOR 100 ns;
		 assert(Input_7SD = "0100")report "error on case" severity error;
		 A_7SD <= "0110"; B_7SD <= "0001"; -- 6 + 1 => 07 (0 0111)
		 WAIT FOR 100 ns;
		 assert(Input_7SD = "0111")report "error on case" severity error;
		 A_7SD <= "0111"; B_7SD <= "0011"; -- 7 + 3 => 0A (0 1010)
		 WAIT FOR 100 ns;
		 assert(Input_7SD = "1010")report "error on case" severity error;
		 A_7SD <= "1000"; B_7SD <= "0101"; -- 8 + 5 => 0D (0 1101)
		 WAIT FOR 100 ns;
		 assert(Input_7SD = "1101")report "error on case" severity error;
		 A_7SD <= "1001"; B_7SD <= "0111"; -- 9 + 7 => 10 (1 0000)
		 WAIT FOR 100 ns;
		 assert(Input_7SD = "0000")report "error on case" severity error;
		 
		
		 --subtraction
		 Operand_7SD <= '1';
		 
		 A_7SD <= "0000"; B_7SD <= "0101"; -- 0 - 5 => -5 (0 0101)
		 WAIT FOR 100 ns;
		 assert(Input_7SD = "1011")report "error on case" severity error;
		 A_7SD <= "0001"; B_7SD <= "0111"; -- 1 - 7 => -6 (0 1000)
		 WAIT FOR 100 ns;
		 assert(Input_7SD = "1010")report "error on case" severity error;
		 A_7SD <= "0010"; B_7SD <= "1001"; -- 2 - 9 => -7 (0 1011)
		 WAIT FOR 100 ns;
		 assert(Input_7SD = "1001")report "error on case" severity error;
		 A_7SD <= "0110"; B_7SD <= "0001"; -- 6 - 1 => 5 (0 0111)
		 WAIT FOR 100 ns;
		 assert(Input_7SD = "0101")report "error on case" severity error;
		 A_7SD <= "0111"; B_7SD <= "0011"; -- 7 - 3 => 4 (0 1010)
		 WAIT FOR 100 ns;
		 assert(Input_7SD = "0100")report "error on case" severity error;
		 A_7SD <= "1000"; B_7SD <= "0101"; -- 8 - 5 => 3 (0 1101)
		 WAIT FOR 100 ns;
		 assert(Input_7SD = "0011")report "error on case" severity error;
		 A_7SD <= "1001"; B_7SD <= "0111"; -- 9 - 7 => 2 (1 0000)
		 WAIT FOR 100 ns;
		 assert(Input_7SD = "0010")report "error on case" severity error;

      wait;
   end process;

END;
`
      },
      {
        id: "7Seg_1",
        name: "7-Segement ISE",
        summary: [
          "<u><b>Building Process</b></u>",
          "Developed a 7-Segment Display system in <b>Xilinx ISE</b> by designing the logic with a <b>VHDL source file</b>, creating a truth table, and coding the entity and architecture. A <b>test bench</b> was implemented to simulate and verify output waveforms, ensuring correct behavior for inputs 0â€“F. Finally, the design was deployed on an <b>FPGA</b>, mapping switches to inputs and LEDs to the display outputs.",
          
          "<u><b>Project Impact</b></u>",
          "This project provided hands-on experience in digital circuit design, verification, and FPGA deployment. It strengthened the ability to translate boolean logic into hardware, apply simulation-based validation, and debug designs effectively. The work reinforced both theoretical knowledge of digital logic and practical skills in hardware implementation.",
          
          "<u><b>Key Skills:</b></u> Xilinx ISE | FPGA | VHDL | Truth Tables | Boolean Logic | Test Benches | Waveform Simulation | Hardware Debugging"
        ],
        images: ["assets/DS_L4_3.png", "assets/DS_L4_4.png", "assets/DS_L4_5.png", "assets/DS_L4_6.png", "assets/DS_L4_7.png", "assets/DS_L4_8.png"],
        videos: [],
        downloads: ["downloads/DS_L4.zip"],
        links: [{ label: "GitHub Repository", url: "https://github.com/Aamir-Ir/VHDL_Achievements/tree/main/VHDL%20-%20Beginner/Seven%20Segment%20Display"}],
        code: `-- VHDL SOURCE CODE FILE FOR COMPARATOR CIRCUIT (DS_L4):
----------------------------------------------------------------------------------
-- Design Name: 7-Segment Display
-- Target Devices: NEXYS 3
-- Description: Displays numbers 0-9 and letters AbCdEF on LED light
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity test is
    Port (  INPUT: in  std_logic_vector (3 downto 0);
				LEDTARGET: out  std_logic_vector (3 downto 0);
            OUTPUT: out std_logic_vector (6 downto 0));
end test;
architecture Behavioral of test is
begin
LEDTARGET<= "0111";
--output for binary inputs for numbers 0-15, output corresponds to each led on the 
--7-segment display, input corresponds to last four switches on board
OUTPUT <= 
	"0000001" WHEN (INPUT = "0000") ELSE
	"1001111" WHEN (INPUT = "0001") ELSE
	"0010010" WHEN (INPUT = "0010") ELSE
	"0000110" WHEN (INPUT = "0011") ELSE
	"1001100" WHEN (INPUT = "0100") ELSE
	"0100100" WHEN (INPUT = "0101") ELSE
	"0100000" WHEN (INPUT = "0110") ELSE
	"0001111" WHEN (INPUT = "0111") ELSE
	"0000000" WHEN (INPUT = "1000") ELSE
	"0000100" WHEN (INPUT = "1001") ELSE
	"0001000" WHEN (INPUT = "1010") ELSE
	"1100000" WHEN (INPUT = "1011") ELSE
	"0110001" WHEN (INPUT = "1100") ELSE
	"1000010" WHEN (INPUT = "1101") ELSE
	"0110000" WHEN (INPUT = "1110") ELSE
	"0111000" WHEN (INPUT = "1111");
end Behavioral;
----------------------------------------------------------------------------------
-- VHDL TEST BENCH CODE FOR SEVEN SEGMENT DECODER:
----------------------------------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
 
ENTITY lab4_TB IS
END lab4_TB;
 
ARCHITECTURE behavior OF lab4_TB IS 
 
    -- Component Declaration for the Unit Under Test (UUT)
    COMPONENT test
    PORT(
         INPUT : IN  std_logic_vector(3 downto 0);
         LEDTARGET : OUT  std_logic_vector(3 downto 0);
         OUTPUT : OUT  std_logic_vector(6 downto 0)
        );
    END COMPONENT;

   --Inputs
   signal INPUT : std_logic_vector(3 downto 0);
   signal LEDTARGET : std_logic_vector(3 downto 0);

 	--Outputs
   signal OUTPUT : std_logic_vector(6 downto 0);
   -- No clocks detected in port list. Replace <clock> below with 
   -- appropriate port name 
 constant period : time := 20 ns;
BEGIN
 
	-- Instantiate the Unit Under Test (UUT)
   uut: test PORT MAP (
          INPUT => INPUT,
          LEDTARGET => LEDTARGET,
          OUTPUT => OUTPUT
        );
 
	

   -- Stimulus process
   stim_proc: process
	
   begin	

		INPUT <= "0000";
		wait for period;
		assert(OUTPUT = "0000001")report "ERROR on case 0000" severity error;
		
		
		INPUT <= "0001";
		wait for period;
		assert(OUTPUT = "1001111")report "ERROR on case 0001" severity error;
		
		
		INPUT <= "0010";
		wait for period;
		assert(OUTPUT = "0010010")report "ERROR on case 0010" severity error;
		
		INPUT <= "0011";
		wait for period;
		assert(OUTPUT = "0000110")report "ERROR on case 0011" severity error;
		
		INPUT <= "0100";
		wait for period;
		assert(OUTPUT = "1001100")report "ERROR on case 0100" severity error;
		
		INPUT <= "0101";
		wait for period;
		assert(OUTPUT = "0100100")report "ERROR on case 0101" severity error;
		
		INPUT <= "0110";
		wait for period;
		assert(OUTPUT = "0100000")report "ERROR on case 0110" severity error;
		
		INPUT <= "0111";
		wait for period;
		assert(OUTPUT = "0001111")report "ERROR on case 0111" severity error;

		
		INPUT <= "1000";
		wait for period;
		assert(OUTPUT = "0000000")report "ERROR on case 1000" severity error;
		
		INPUT <= "1001";
		wait for period;
		assert(OUTPUT = "0000100")report "ERROR on case 1001" severity error;
		
		INPUT <= "1010";
		wait for period;
		assert(OUTPUT = "0001000")report "ERROR on case 1010" severity error;
		
		INPUT <= "1011";
		wait for period;
		assert(OUTPUT = "1100000")report "ERROR on case 1011" severity error;
		
		INPUT <= "1100";
		wait for period;
		assert(OUTPUT = "0110001")report "ERROR on case 1100" severity error;
		
		INPUT <= "1101";
		wait for period;
		assert(OUTPUT = "1000010")report "ERROR on case 1101" severity error;
		
		INPUT <= "1110";
		wait for period;
		assert(OUTPUT = "0110000")report "ERROR on case 1110" severity error;
		
		INPUT <= "1111";
		wait for period;
		assert(OUTPUT = "0111000")report "ERROR on case 1111" severity error;

      wait;
   end process;

END;`
      },
      {
        id: "comparator",
        name: "Comparator Circuit",
        summary: [
          "<u><b>Building Process</b></u>",
          "The Comparator Circuit project involved understanding the logic behind the comparison, creating a truth table and boolean function, and then implementing the circuit. The design was created using a <b>VHDL Source File</b> to define the entity and code the architecture in <b>Xilinx ISE</b>. Afterwards, a <b>test bench</b> was written to simulate the circuit and generate a <b>waveform</b>. Finally, the program was deployed on a <b>FPGA</b>, mapping switches to inputs and LEDs to outputs.",
          "<u><b>Project Impact</b></u>",
          "This project strengthened practical knowledge of digital logic design and FPGA implementation. It provided hands-on experience translating boolean functions into working hardware, validating designs via simulation, and deploying them on an FPGA. It also enhanced problem-solving, debugging, and verification skills essential for hardware design.",
          "<u><b>Key Skills:</b></u> Xilinx ISE | FPGA | Truth Tables | Boolean Functions | Schematic Capture | Test Bench Code | Waveform Simulation."
        ],
        images: ["assets/DS_L3_1.png", "assets/DS_L3_2.png", "assets/DS_L3_6.png", "assets/DS_L3_3.png", "assets/DS_L3_5.png", "assets/DS_L3_4.png", "assets/DS_L3_7.png", "assets/DS_L3_8.png"],
        videos: [],
        downloads: ["downloads/DS_L3.zip"],
        links: [{ label: "GitHub Repository", url: "https://github.com/Aamir-Ir/VHDL_Achievements/tree/main/VHDL%20-%20Beginner/Comparator%20Combinational%20Circuit"}],
        code: `-- VHDL SOURCE CODE FILE FOR COMPARATOR CIRCUIT (DS_L3):
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity comparator_VHDL is
    Port ( A1 : in  STD_LOGIC;
           A0 : in  STD_LOGIC;
           B1 : in  STD_LOGIC;
           B0 : in  STD_LOGIC;
           GT : out  STD_LOGIC;
           EQ : out  STD_LOGIC;
           LT : out  STD_LOGIC);
end comparator_VHDL;

architecture Behavioral of comparator_VHDL is

begin
GT<=((A1 and not B1) or (A0 and not B1 and not B0) or (A1 and A0 and not B0));
EQ<=((not A1 and not A0 and not B1 and not B0) or (not A1 and A0 and not B1 and B0) or(A1 and not A0 and B1 and not B0) or(A1 and A0 and B1 and B0) );
LT<=((B1 and not A1) or (B0 and not A1 and not A0) or (B1 and B0 and not A0));

end Behavioral;
----------------------------------------------------------------------------------
-- VHDL TEST BENCH CODE:
----------------------------------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
 
ENTITY comparator_TB IS
END comparator_TB;
 
ARCHITECTURE behavior OF comparator_TB IS 
 
    COMPONENT comparator_VHDL
    PORT(
         A1 : IN  std_logic;
         A0 : IN  std_logic;
         B1 : IN  std_logic;
         B0 : IN  std_logic;
         GT : OUT  std_logic;
         EQ : OUT  std_logic;
         LT : OUT  std_logic
        );
    END COMPONENT;
    

   --Inputs
   signal A1 : std_logic := '0';
   signal A0 : std_logic := '0';
   signal B1 : std_logic := '0';
   signal B0 : std_logic := '0';

 	--Outputs
   signal GT : std_logic;
   signal EQ : std_logic;
   signal LT : std_logic;
 
   
 
BEGIN
 
	-- Instantiate the Unit Under Test (UUT)
   uut: comparator_VHDL PORT MAP (
          A1 => A1,
          A0 => A0,
          B1 => B1,
          B0 => B0,
          GT => GT,
          EQ => EQ,
          LT => LT
        );

   -- Stimulus process
   stim_proc: process
		constant period: time := 20 ns;
   begin		
		A1 <= '0';
		A0 <= '0';
		B1 <= '0';
		B0 <= '0';
		wait for period;
		assert (LT = '0') report "ERROR on case 0000" severity error;
		assert (EQ = '1') report "ERROR on case 0000" severity error;
		assert (GT = '0') report "ERROR on case 0000" severity error;
		
		A1 <= '0';
		A0 <= '0';
		B1 <= '0';
		B0 <= '1';
		wait for period;
		assert (LT = '1') report "ERROR on case 0001" severity error;
		assert (EQ = '0') report "ERROR on case 0001" severity error;
		assert (GT = '0') report "ERROR on case 0001" severity error;
		
		A1 <= '0';
		A0 <= '0';
		B1 <= '1';
		B0 <= '0';
		wait for period;
		assert (LT = '1') report "ERROR on case 0010" severity error;
		assert (EQ = '0') report "ERROR on case 0010" severity error;
		assert (GT = '0') report "ERROR on case 0010" severity error;
		
		A1 <= '0';
		A0 <= '0';
		B1 <= '1';
		B0 <= '1';
		wait for period;
		assert (LT = '1') report "ERROR on case 0011" severity error;
		assert (EQ = '0') report "ERROR on case 0011" severity error;
		assert (GT = '0') report "ERROR on case 0011" severity error;
		
		A1 <= '0';
		A0 <= '1';
		B1 <= '0';
		B0 <= '0';
		wait for period;
		assert (LT = '0') report "ERROR on case 0100" severity error;
		assert (EQ = '0') report "ERROR on case 0100" severity error;
		assert (GT = '1') report "ERROR on case 0100" severity error;
		
		A1 <= '0';
		A0 <= '1';
		B1 <= '0';
		B0 <= '1';
		wait for period;
		assert (LT = '0') report "ERROR on case 0101" severity error;
		assert (EQ = '1') report "ERROR on case 0101" severity error;
		assert (GT = '0') report "ERROR on case 0101" severity error;
		
		A1 <= '0';
		A0 <= '1';
		B1 <= '1';
		B0 <= '0';
		wait for period;
		assert (LT = '1') report "ERROR on case 0110" severity error;
		assert (EQ = '0') report "ERROR on case 0110" severity error;
		assert (GT = '0') report "ERROR on case 0110" severity error;
		
		A1 <= '0';
		A0 <= '1';
		B1 <= '1';
		B0 <= '1';
		wait for period;
		assert (LT = '1') report "ERROR on case 0111" severity error;
		assert (EQ = '0') report "ERROR on case 0111" severity error;
		assert (GT = '0') report "ERROR on case 0111" severity error;
		
		A1 <= '1';
		A0 <= '0';
		B1 <= '0';
		B0 <= '0';
		wait for period;
		assert (LT = '0') report "ERROR on case 1000" severity error;
		assert (EQ = '0') report "ERROR on case 1000" severity error;
		assert (GT = '1') report "ERROR on case 1000" severity error;
		
		A1 <= '1';
		A0 <= '0';
		B1 <= '0';
		B0 <= '1';
		wait for period;
		assert (LT = '0') report "ERROR on case 1001" severity error;
		assert (EQ = '0') report "ERROR on case 1001" severity error;
		assert (GT = '1') report "ERROR on case 1001" severity error;
		
		A1 <= '1';
		A0 <= '0';
		B1 <= '1';
		B0 <= '0';
		wait for period;
		assert (LT = '0') report "ERROR on case 1010" severity error;
		assert (EQ = '1') report "ERROR on case 1010" severity error;
		assert (GT = '0') report "ERROR on case 1010" severity error;
		
		A1 <= '1';
		A0 <= '0';
		B1 <= '1';
		B0 <= '1';
		wait for period;
		assert (LT = '1') report "ERROR on case 1011" severity error;
		assert (EQ = '0') report "ERROR on case 1011" severity error;
		assert (GT = '0') report "ERROR on case 1011" severity error;
		
		A1 <= '1';
		A0 <= '1';
		B1 <= '0';
		B0 <= '0';
		wait for period;
		assert (LT = '0') report "ERROR on case 1100" severity error;
		assert (EQ = '0') report "ERROR on case 1100" severity error;
		assert (GT = '1') report "ERROR on case 1100" severity error;
		
		A1 <= '1';
		A0 <= '1';
		B1 <= '0';
		B0 <= '1';
		wait for period;
		assert (LT = '0') report "ERROR on case 1101" severity error;
		assert (EQ = '0') report "ERROR on case 1101" severity error;
		assert (GT = '1') report "ERROR on case 1101" severity error;
		
		A1 <= '1';
		A0 <= '1';
		B1 <= '1';
		B0 <= '0';
		wait for period;
		assert (LT = '0') report "ERROR on case 1110" severity error;
		assert (EQ = '0') report "ERROR on case 1110" severity error;
		assert (GT = '1') report "ERROR on case 1110" severity error;
		
		A1 <= '1';
		A0 <= '1';
		B1 <= '1';
		B0 <= '1';
		wait for period;
		assert (LT = '0') report "ERROR on case 1111" severity error;
		assert (EQ = '1') report "ERROR on case 1111" severity error;
		assert (GT = '0') report "ERROR on case 1111" severity error;
		
      WAIT;
   end process;

END;
----------------------------------------------------------------------------------
-- UCF FILE:
NET A1 LOC=T5; //(leftmost slide switch on NEXYS 3 board)
NET A0 LOC=V8; //(second slide switch on NEXYS 3 board)
NET B1 LOC=U8; //(third slide switch on NEXYS 3 board)
NET B0 LOC=N8; //(fourth slide switch on NEXYS 3 board)
NET GT LOC=T11; //(leftmost LED  on NEXYS 3 board)
NET EQ LOC=R11; // (second LED  on NEXYS 3 board)
NET LT LOC=N11; //(third LED  on NEXYS 3 board)
`
      },
      {
        id: "Combo",
        name: "Combinational Circuit",
        summary: [
          "<u><b>Building Process</b></u>",
          "The Combinational Circuit project involved understanding the given circuit, creating its truth table and boolean function, and then implementing the circuit. The design was created using the <b>Schematic Capture</b> tool in <b>Xilinx ISE</b>. Afterwards, a <b>test bench</b> was written to simulate the circuit and generate a <b>waveform</b>. Finally, the program was deployed on a <b>FPGA</b>, mapping switches to inputs and LEDs to outputs.",
          "<u><b>Project Impact</b></u>",
          "This project strengthened practical knowledge of digital logic design and FPGA implementation. It provided hands-on experience translating boolean functions into working hardware, validating designs via simulation, and deploying them on an FPGA. It also enhanced problem-solving, debugging, and verification skills essential for hardware design.",
          "<u><b>Key Skills:</b></u> Xilinx ISE | FPGA | Truth Tables | Boolean Functions | Schematic Capture | Test Bench Code | Waveform Simulation."
        ],
        images: ["assets/DS_L2_1.png", "assets/DS_L2_5.png", "assets/DS_L2_3.png", "assets/DS_L2_2.png", "assets/DS_L2_4.png"],
        videos: [],
        downloads: ["downloads/DS_L2.zip"],
        links: [{ label: "GitHub Repository", url: "https://github.com/Aamir-Ir/VHDL_Achievements/tree/main/VHDL%20-%20Beginner/Simple%20Combinational%20Circuit"}],
        code: `-- VHDL TEST BENCH CODE (DS_L2)
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;
LIBRARY UNISIM;
USE UNISIM.Vcomponents.ALL;

ENTITY TripGenie_TripGenie_sch_tb IS
END TripGenie_TripGenie_sch_tb;

ARCHITECTURE behavioral OF TripGenie_TripGenie_sch_tb IS 

   COMPONENT TripGenie
   PORT( MtPilot	:	IN	STD_LOGIC; 
          SilverCity	:	IN	STD_LOGIC; 
          Hooterville	:	IN	STD_LOGIC; 
          Mayberry	:	IN	STD_LOGIC; 
          HWY1	:	OUT	STD_LOGIC; 
          HWY2	:	OUT	STD_LOGIC; 
          HWY3	:	OUT	STD_LOGIC; 
          HWY4	:	OUT	STD_LOGIC; 
          HWY5	:	OUT	STD_LOGIC; 
          HWY6	:	OUT	STD_LOGIC);
   END COMPONENT;

   SIGNAL MtPilot	:	STD_LOGIC;
   SIGNAL SilverCity	:	STD_LOGIC;
   SIGNAL Hooterville	:	STD_LOGIC;
   SIGNAL Mayberry	:	STD_LOGIC;
   SIGNAL HWY1	:	STD_LOGIC;
   SIGNAL HWY2	:	STD_LOGIC;
   SIGNAL HWY3	:	STD_LOGIC;
   SIGNAL HWY4	:	STD_LOGIC;
   SIGNAL HWY5	:	STD_LOGIC;
   SIGNAL HWY6	:	STD_LOGIC;

BEGIN

   UUT: TripGenie PORT MAP(
		MtPilot => MtPilot, 
		SilverCity => SilverCity, 
		Hooterville => Hooterville, 
		Mayberry => Mayberry, 
		HWY1 => HWY1, 
		HWY2 => HWY2, 
		HWY3 => HWY3, 
		HWY4 => HWY4, 
		HWY5 => HWY5, 
		HWY6 => HWY6
   );

-- *** Test Bench - User Defined Section ***
   tb : PROCESS
	constant period: time := 20 ns;
   BEGIN
	
	Mayberry<= '0';
	MtPilot<= '0';
	SilverCity<= '0';
	Hooterville<= '0';
	wait for period;
	assert((HWY1='0') and(HWY2='0') and(HWY3='0') and(HWY1='0') and(HWY1='0') and(HWY1='0'))
	report "test failed for input combination 0000" severity error;
	
	Mayberry<= '0';
	MtPilot<= '0';
	SilverCity<= '0';
	Hooterville<= '1';
	wait for period;
	assert((HWY1='0') and(HWY2='0') and(HWY3='0') and(HWY4='0') and(HWY5='0') and(HWY6='0'))
	report "test failed for input combination 0001" severity error;
	
	Mayberry<= '0';
	MtPilot<= '0';
	SilverCity<= '1';
	Hooterville<= '0';
	wait for period;
	assert((HWY1='0') and(HWY2='0') and(HWY3='0') and(HWY4='0') and(HWY5='0') and(HWY6='0'))
	report "test failed for input combination 0010" severity error;
	
	Mayberry<= '0';
	MtPilot<= '0';
	SilverCity<= '1';
	Hooterville<= '1';
	wait for period;
	assert((HWY1='0') and(HWY2='0') and(HWY3='1') and(HWY4='0') and(HWY5='0') and(HWY6='0'))
	report "test failed for input combination 0011" severity error;
	
	Mayberry<= '0';
	MtPilot<= '1';
	SilverCity<= '0';
	Hooterville<= '0';
	wait for period;
	assert((HWY1='0') and(HWY2='0') and(HWY3='0') and(HWY4='0') and(HWY5='0') and(HWY6='0'))
	report "test failed for input combination 0100" severity error;
	
	Mayberry<= '0';
	MtPilot<= '1';
	SilverCity<= '0';
	Hooterville<= '1';
	wait for period;
	assert((HWY1='0') and(HWY2='1') and(HWY3='0') and(HWY4='0') and(HWY5='0') and(HWY6='0'))
	report "test failed for input combination 0101" severity error;
	
	Mayberry<= '0';
	MtPilot<= '1';
	SilverCity<= '1';
	Hooterville<= '0';
	wait for period;
	assert((HWY1='0') and(HWY2='0') and(HWY3='0') and(HWY4='0') and(HWY5='0') and(HWY6='1'))
	report "test failed for input combination 0110" severity error;
	
	Mayberry<= '0';
	MtPilot<= '1';
	SilverCity<= '1';
	Hooterville<= '1';
	wait for period;
	assert((HWY1='0') and(HWY2='0') and(HWY3='0') and(HWY4='0') and(HWY5='0') and(HWY6='0'))
	report "test failed for input combination 0111" severity error;
	
	Mayberry<= '1';
	MtPilot<= '0';
	SilverCity<= '0';
	Hooterville<= '0';
	wait for period;
	assert((HWY1='0') and(HWY2='0') and(HWY3='0') and(HWY4='0') and(HWY5='0') and(HWY6='0'))
	report "test failed for input combination 1000" severity error;
	
	Mayberry<= '1';
	MtPilot<= '0';
	SilverCity<= '0';
	Hooterville<= '1';
	wait for period;
	assert((HWY1='1') and(HWY2='0') and(HWY3='0') and(HWY4='0') and(HWY5='0') and(HWY6='0'))
	report "test failed for input combination 1001" severity error;
	
	Mayberry<= '1';
	MtPilot<= '0';
	SilverCity<= '1';
	Hooterville<= '0';
	wait for period;
	assert((HWY1='0') and(HWY2='0') and(HWY3='0') and(HWY4='1') and(HWY5='0') and(HWY6='0'))
	report "test failed for input combination 1010" severity error;
	
	Mayberry<= '1';
	MtPilot<= '0';
	SilverCity<= '1';
	Hooterville<= '1';
	wait for period;
	assert((HWY1='0') and(HWY2='0') and(HWY3='0') and(HWY4='0') and(HWY5='0') and(HWY6='0'))
	report "test failed for input combination 1011" severity error;
	
	Mayberry<= '1';
	MtPilot<= '1';
	SilverCity<= '0';
	Hooterville<= '0';
	wait for period;
	assert((HWY1='0') and(HWY2='0') and(HWY3='0') and(HWY4='0') and(HWY5='1') and(HWY6='0'))
	report "test failed for input combination 1100" severity error;
	
	Mayberry<= '1';
	MtPilot<= '1';
	SilverCity<= '0';
	Hooterville<= '1';
	wait for period;
	assert((HWY1='0') and(HWY2='0') and(HWY3='0') and(HWY4='0') and(HWY5='0') and(HWY6='0'))
	report "test failed for input combination 1101" severity error;
	
	Mayberry<= '1';
	MtPilot<= '1';
	SilverCity<= '1';
	Hooterville<= '0';
	wait for period;
	assert((HWY1='0') and(HWY2='0') and(HWY3='0') and(HWY4='0') and(HWY5='0') and(HWY6='0'))
	report "test failed for input combination 1110" severity error;
	
	Mayberry<= '1';
	MtPilot<= '1';
	SilverCity<= '1';
	Hooterville<= '1';
	wait for period;
	assert((HWY1='0') and(HWY2='0') and(HWY3='0') and(HWY4='0') and(HWY5='0') and(HWY6='0'))
	report "test failed for input combination 1111" severity error;
	
	
	
      WAIT; -- will wait forever
   END PROCESS;
-- *** End Test Bench - User Defined Section ***

END;
`
      },
      {
        id: "Simple",
        name: "Simple Circuit",
        summary: [
          "<u><b>Building Process</b></u>",
          "The building process of the Simple Curcuit consisted of understanding the circuit presented and based on that creating a truth table, boolean function, and a circuit. Once that was done the circuit was designed using the <b>Schematic Capture</b> tool in <b>Xilinx ISE</b> after this a <b>test bench</b> was created to simulate the design and showcase a <b>waveform</b>. Finally the program was run on a <b>FPGA</b> and the switches were mapped to the input and the LEDs to the output.",
          "<u><b>Project Impact</b></u>",
          "This project strengthened practical understanding of digital logic design and FPGA implementation. It enabled hands-on experience with translating boolean functions into working hardware, validating designs through simulation, and deploying circuits on an FPGA. The project also enhanced problem-solving, debugging, and verification skills crucial for hardware design.",
          "<u><b>Key Skills:</b></u> Xilinx ISE | FPGA | Truth Tables | Boolean Functions | Schematic Captur | Test Bench Code | Waveform Simulation."
        ],
        images: ["assets/DS_L1_1.png", "assets/DS_L1_2.png", "assets/DS_L1_3.png", "assets/DS_L1_4.png"],
        videos: [],
        downloads: ["downloads/DS_L1.zip"],
        links: [{ label: "GitHub Repository", url: "https://github.com/Aamir-Ir/VHDL_Achievements/tree/main/VHDL%20-%20Beginner/Simple%20AND%20Gate"}],
        code: `-- VHDL TEST BENCH CODE (DS_L1)
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;
LIBRARY UNISIM;
USE UNISIM.Vcomponents.ALL;
ENTITY SimpleLogic_SimpleLogic_sch_tb IS
END SimpleLogic_SimpleLogic_sch_tb;
ARCHITECTURE behavioral OF SimpleLogic_SimpleLogic_sch_tb IS 

   COMPONENT SimpleLogic
   PORT( A	:	IN	STD_LOGIC; 
          B	:	IN	STD_LOGIC; 
			 C	:	IN	STD_LOGIC;
          F	:	OUT	STD_LOGIC);
   END COMPONENT;

   SIGNAL A	:	STD_LOGIC;
   SIGNAL B	:	STD_LOGIC;
	SIGNAL C	:	STD_LOGIC;
   SIGNAL F	:	STD_LOGIC;

BEGIN

   UUT: SimpleLogic PORT MAP(
		A => A, 
		B => B, 
		C => C,
		F => F
   );

-- *** Test Bench - User Defined Section ***
   tb : PROCESS
	constant period: time:= 20ns;
   BEGIN
      
		A <= '0';
		B <= '0';
		C <= '0';
		wait for period;
		assert (F = '1')
		report "test failed for input combination 000" severity error;
		
		A <= '0';
		B <= '0';
		C <= '1';
		wait for period;
		assert (F = '1')
		report "test failed for input combination 001" severity error;
		
		A <= '0';
		B <= '1';
		C <= '0';
		wait for period;
		assert (F = '1')
		report "test failed for input combination 010" severity error;      	

		A <= '0';
		B <= '1';
		C <= '1';
		wait for period;
		assert (F = '0')
		report "test failed for input combination 011" severity error;
		
		A <= '1';
		B <= '0';
		C <= '0';
		wait for period;
		assert (F = '1')
		report "test failed for input combination 100" severity error;
		
		A <= '1';
		B <= '0';
		C <= '1';
		wait for period;
		assert (F = '0')
		report "test failed for input combination 101" severity error;
		
		A <= '1';
		B <= '1';
		C <= '0';
		wait for period;
		assert (F = '0')
		report "test failed for input combination 110" severity error;
		
		A <= '1';
		B <= '1';
		C <= '1';
		wait for period;
		assert (F = '0')
		report "test failed for input combination 111" severity error;
		
				
		WAIT; -- will wait forever
   END PROCESS;
-- *** End Test Bench - User Defined Section ***

END;`
      }
    ],
    "Professional Development": [
      {
        id: "certifications",
        name: "Certifications",
        summary: [
          "- Introduction to Cybersecurity (WATSPEED University of Waterloo) - <a href=https://github.com/Aamir-Ir/Certifications-Earned/blob/main/Introduction%20to%20Cybersecurity%20(Self-Paced)%20Certificate%20Completion%20WATSPEED%20UW.pdf>Link to Certification</a>",
          "- ARM Assembly for Hackers (Udemy) - <a href=https://github.com/Aamir-Ir/Certifications-Earned/blob/main/ARM%20Assembly%20for%20Hacker%20Certificate%20of%20Completion.pdf>Link to Certification</a>",
          "- Complete Responsive Web Development 4 Courses in 1 (Udemy) - <a href=https://github.com/Aamir-Ir/Certifications-Earned/blob/main/Complete%20Responsive%20Web%20Development%204%20courses%20in%201.pdf>Link to Certification</a>",
          "- Java Programming for Beginners (Udemy) - <a href=https://github.com/Aamir-Ir/Certifications-Earned/blob/main/Java%20Programming%20for%20Complete%20Beginners.pdf>Link to Certification</a>",
          "- JavaScript Fundamentals: A Course for Absolute Beginners (Udemy) - <a href=https://github.com/Aamir-Ir/Certifications-Earned/blob/main/JavaScript%20Fundamentals%20A%20Course%20for%20Absolute%20Beginners.pdf>Link to Certification</a><br><br>",
          "<b>Key Skills:</b> CyberSecurity | Penetration Testing | AWS Cloud Features | ARM | Web Development | Java | JavaScript | HTML | CSS."
        ],
        images: [],
        videos: [],
        downloads: [],
        links: [],
        code: null
      },
      {
        id: "electrical_mechanical_portfolio",
        name: "Electrical / Mechanical Portfolio",
        summary: [
          "<iframe src=downloads/Aamir_Portfolio_Template.pdf width=100% height=2200px style=border:none;></iframe>",
          "<p><b>Key Skills:</b> BreadBoard | Oscilloscope | Function Generator | AutoCAD | Exploded Animation | SolidWorks | Assembly | Orthographic Drawings | Reverse Engineering | Tolerance | 3D Printing | MATLAB</p>"
        ],
        images: [],
        videos: [],
        downloads: [],
        links: [],
        code: null
      }
    ]
  };

  const categoryNav = document.getElementById('category-nav');
  const projectNav = document.getElementById('project-nav');
  const projectDetail = document.getElementById('project-detail');

  let activeCategoryBtn = null;
  let activeProjectBtn = null;

  function clearActive(buttons) {
    buttons.forEach(btn => btn.classList.remove('active'));
  }

  function renderCategories() {
    Object.keys(projectsData).forEach((category) => {
      const btn = document.createElement('button');
      btn.textContent = category;
      btn.onclick = () => selectCategory(category, btn);
      categoryNav.appendChild(btn);
    });
  }

  function renderProjects(category) {
    projectNav.innerHTML = '';
    projectsData[category].forEach((project) => {
      const btn = document.createElement('button');
      btn.textContent = project.name;
      btn.onclick = () => selectProject(project, btn);
      btn.dataset.projectId = project.id;
      projectNav.appendChild(btn);
    });
  }

  function selectCategory(category, btn) {
    if (activeCategoryBtn) activeCategoryBtn.classList.remove('active');
    btn.classList.add('active');
    activeCategoryBtn = btn;
    renderProjects(category);
  }

  function selectProject(project, btn) {
    if (activeProjectBtn) activeProjectBtn.classList.remove('active');
    btn.classList.add('active');
    activeProjectBtn = btn;

    projectDetail.innerHTML = `
      <h2>${project.name}</h2>
      ${project.summary.map(p => `<p>${p}</p>`).join("")}
      <div class="project-media">
        ${project.videos.map(video => {
          if (video.includes("drive.google.com")) {
            return `<div class="responsive-video"><iframe src="${video}" allow="autoplay" allowfullscreen></iframe></div>`;
          } else {
            return `<video controls src="${video}"></video>`;
          }
        }).join("")}
        ${project.images.map(img => `<img src="${img}" alt="${project.name} Image">`).join("")}
      </div>
      ${project.links.length > 0 ? `<div class="links">${project.links.map(link => `<a href="${link.url}" target="_blank" rel="noopener">${link.label}</a>`).join('')}</div>` : ''}
      ${project.downloads.length > 0 ? project.downloads.map(file => `<a href="${file}" class="download" download>Download</a>`).join('') : ''}
      ${project.code ? `<pre class="language-javascript"><code>${escapeHtml(project.code)}</code></pre>` : ''}
    `;

    if (project.code) Prism.highlightAll();
  }

  function escapeHtml(text) {
    return text.replace(/&/g, "&amp;")
               .replace(/</g, "&lt;")
               .replace(/>/g, "&gt;")
               .replace(/"/g, "&quot;")
               .replace(/'/g, "&#039;");
  }

  function selectById(projectId) {
    for (const category in projectsData) {
      const project = projectsData[category].find(p => p.id === projectId);
      if (project) {
        const categoryButtons = categoryNav.querySelectorAll('button');
        categoryButtons.forEach(btn => {
          if (btn.textContent === category) selectCategory(category, btn);
        });

        setTimeout(() => {
          const projectButtons = projectNav.querySelectorAll('button');
          projectButtons.forEach(btn => {
            if (btn.dataset.projectId === projectId) selectProject(project, btn);
          });
        }, 10);

        return true;
      }
    }
    return false;
  }

  document.addEventListener('DOMContentLoaded', () => {
    renderCategories();

    const hash = window.location.hash.slice(1); // .toLowerCase()
    if (hash && !selectById(hash)) {
      const firstCategory = Object.keys(projectsData)[0];
      selectCategory(firstCategory, categoryNav.querySelector('button'));
      const firstProjectBtn = projectNav.querySelector('button');
      selectProject(projectsData[firstCategory][0], firstProjectBtn);
    } else if (!hash) {
      const firstCategory = Object.keys(projectsData)[0];
      selectCategory(firstCategory, categoryNav.querySelector('button'));
      const firstProjectBtn = projectNav.querySelector('button');
      selectProject(projectsData[firstCategory][0], firstProjectBtn);
    }
  });
</script>

</body>
</html>
